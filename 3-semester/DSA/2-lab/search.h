/* =================================================
*  Выполнил: Студент Лебедев И. И. 
*  Группа: М3О-211Б-20
*  ================================================= */

#pragma once            // Для избежания проблемы двойного включения

#include <iostream>     // Библиотека для управления входным/выходным потоком
#include <tuple>        // Библиотека для использования кортежей
#include <chrono>       // Библиотека для работы со временем
#include <iomanip>      // Библиотека для управления стилем ввода/вывода
#include <limits>       // Библиотека для использования максимального значения шаблонного типа

#define NOT_FOUND -1            // Значение, которое будет возвращаться, если ключ не найден
#define PRINT_FUNC_NAME(var) std::cout << setw(14) << var   // Макрос для вывода названия функции

using namespace std;         // Пространство имён std для использования функций стандартной библиотеки
using namespace std::chrono; // Пространство имён std::chrono для использования функций работы со временем

/* ============================================================================================================================
*                                   П Р О Т О Т И П Ы   Ф У Н К Ц И Й   П О И С К А
*  ============================================================================================================================ */

template <typename T>                                       // Шаблон для функции
tuple<int, uint, uint, uint> SAlgoSearch(                   // Функция последовательного поиска
                                            T* input        // Входной массив
                                            , size_t size   // Размер входного массива
                                            , T key         // Искомый ключ
                                            );              // Конец объявления ф-ции последовательного поиска

template <typename T>                                       // Шаблон для функции
tuple<int, uint, uint, uint> QAlgoSearch(                   // Функция поиска по алгоритму Q
                                        T* input            // Входной массив
                                        , size_t size       // Размер входного массива
                                        , T key             // Искомый ключ
                                        );                  // Конец объявления ф-ции поиска по алгоритму Q
                                        
template <typename T>                                       // Шаблон для функции
tuple<int, uint, uint, uint> TAlgoSearch(                   // Функция поиска по алгоритму Т
                                        T* input            // Входной массив
                                        , size_t size       // Размер входного массива
                                        , T key             // Искомый ключ
                                        );                  // Конец объявления ф-ции поиска по алгоритму Т

template <typename T>                                       // Шаблон для функции
tuple<int, uint, uint, uint> BAlgoSearch(                   // Функция поиска по алгоритму B
                                        T* input            // Входной массив
                                        , size_t size       // Размер входного массива
                                        , T key             // Искомый ключ
                                        );                  // Конец объявления ф-ции поиска по алгоритму B

/* ============================================================================================================================
*                                К О Н Е Ц   П Р О Т О Т И П О В   Ф У Н К Ц И Й   П О И С К А
*  ============================================================================================================================ */

/* ============================================================================================================================
*                                    О П Р Е Д Е Л Е Н И Е   Ф У Н К Ц И Й   П О И С К А
*  ============================================================================================================================ */




template <typename T>                                       // Шаблон для функции
tuple<int, uint, uint, uint> SAlgoSearch(             // Функция поиска по алгоритму Q
                                        T* input            // Входной массив
                                        , size_t size       // Размер входного массива
                                        , T key             // Искомый ключ
                                        ){
    PRINT_FUNC_NAME(__func__); // Печатаем название исполняемой функции
    
    steady_clock::time_point start = steady_clock::now(); // Засечь начальный момент времени

    size_t occurrences_count = 0;
    uint comparisons = 0;
    
    for (size_t i = 0; i < size; ++i){
        //if(!occurrences){
        comparisons += 2;
        if(input[i] == key) {
            auto finish = steady_clock::now();      // Засечь время окончания выполнения функции
            occurrences_count++;
            for (int j = i + 1; input[j] == input[i] && j < size; ++j){
                occurrences_count++;
            }
            return {                            // Вернуть кортеж из:
                    i                           // Индекса
                    , comparisons               // Количества сравнений
                    , occurrences_count         // Количества вхождений
                    , duration_cast<microseconds>(finish - start).count() // Времени, затраченного на поиск
                   }; // Конец возвращаемого кортежа
        }
    }
    auto finish = steady_clock::now();  // Засечь время окончания выполнения функции
    return {                            // Вернуть кортеж из:
            NOT_FOUND                   // Индекса
            , comparisons               // Количества сравнений
            , occurrences_count         // Количества вхождений
            , duration_cast<microseconds>(finish - start).count() // Времени, затраченного на поиск
           };                           // Конец возвращаемого кортежа
} // Конец функции поиска по алгоритму S

template <typename T>                                       // Шаблон для функции
tuple<int, uint, uint, uint> QAlgoSearch(                   // Функция последовательного поиска по алгоритму Q
                                            T* input        // Входной массив
                                            , size_t size   // Размер входного массива
                                            , T key         // Искомый ключ
                                            ){              // Конец объявления ф-ции последовательного поиска
    PRINT_FUNC_NAME(__func__); // Печатаем название исполняемой функции

    steady_clock::time_point start = steady_clock::now();   // Засечь начальный момент времени

    uint comparisons = 0;           // Обнулить счётчик сравнений
    uint occurrences_count = 0;     // Обнулить счётчик вхождений
    size_t i = 0;                   // Обнулить счётчик элементов

    T last = input[size - 1];       // Записать во временную переменную значение последнего элемента массива
    input[size - 1] = key;          // Записать в последний элемент массива искомый ключ
    
    while(input[i] != key){         // Пока i-й элемент массива не равен искомому ключу
        i++;                        // Перейти к следующему элементу массива
    }                               // Конец поиска по массиву

    comparisons = i;                // Количество сравнений равно количеству итераций в цикле
    input[size - 1] = last;         // Записать в конец массива значение временной переменной
    comparisons += 2;               // Увеличить счётчик сравнений на 2 (в след. усл. операторе будет два условия)

    if(i < size - 1 || input[size - 1] == key) { // Если вышли из цикла не доходя до последнего элемента или же последний элемент равен ключу

        auto finish = steady_clock::now();       // Засечь время окончания выполнения функции
        occurrences_count++;                     // Увеличить счётчик количества вхождений

        for (int j = i + 1; input[j] == key && j < size; ++j){ // Перебор части массива "правее" найденного ключа до момента, 
                                                               // пока не встретится отличающийся элемент или не дойдём до конца массива
            occurrences_count++;            // Увеличить счётчик количества вхождений
        }                                   // Конец перебора для поиска ключей "правее" найденного

        return {                            // Вернуть кортеж из:
                i                           // Индекса
                , comparisons               // Количества сравнений
                , occurrences_count         // Количества вхождений
                , duration_cast<microseconds>(finish - start).count() // Времени, затраченного на поиск
               }; // Конец возвращаемого кортежа
    } // Конец рассмотрения случая, если ключ найден

    auto finish = steady_clock::now();      // Засечь время окончания выполнения функции
    return {                        // Вернуть кортеж из:
            NOT_FOUND                   // Индекса
            , comparisons               // Количества сравнений
            , occurrences_count         // Количества вхождений
            , duration_cast<microseconds>(finish - start).count() // Времени, затраченного на поиск
           }; // Конец возвращаемого кортежа
} // Конец поиска по алгоритму Q

template <typename T>                                       // Шаблон для функции
tuple<int, uint, uint, uint> TAlgoSearch(                   // Функция поиска по алгоритму Т
                                        T* input            // Входной массив
                                        , size_t size       // Размер входного массива
                                        , T key             // Искомый ключ
                                        ){                  // Конец объявления ф-ции поиска по алгоритму Т
    PRINT_FUNC_NAME(__func__); // Печатаем название исполняемой функции

    steady_clock::time_point start = steady_clock::now(); // Засечь начальный момент времени

    uint comparisons = 0;       // Обнулить счётчик сравнений
    uint occurrences_count = 0; // Обнулить счётчик колиечства вхождений
    size_t i = 0;               // Обнулить счётчик элементов
    // input = (T*)realloc(input, (size + 1)*sizeof(T)); // Реаллокация памяти (увеличиваем размер массива на 1, чтобы записать N+1 элемент)
    // input[size] = INT32_MAX; // Создаём фиктивную запись в N+1 элементе массива
                                // Для типа char случится переполнение. Это плохо. Для long может и не хватить
    input[size] = numeric_limits<T>::max(); // Присваиваем N+1 элементу максимальное значение текущего типа данных
    while(key > input[i]){  // Пока ключ больше текущего элемента
        i++;                // Переходить к следующему элементу
    }                       // Конец цикла "пока"

    comparisons = i + 1; // Присвоить счётчику сравнений значение количества итераций + 1 (из-за последующего усл. опер.)

    if (input[i] == key){    // Если искомый элемент найден
        auto finish = steady_clock::now();      // Засечь время окончания выполнения функции

        occurrences_count++; // Увеличить счётчик количества вхождений
        
        for (int j = i + 1; input[j] == key && j < size; ++j){ // Перебор части массива "правее" найденного ключа до момента, 
                                                               // пока не встретится отличающийся элемент или не дойдём до конца массива
                occurrences_count++;            // Увеличить счётчик количества вхождений
        }                                       // Конец перебора для поиска ключей "правее" найденного

        // input = (T*)realloc(input, (size - 1)*sizeof(T)); // Повторная реаллокация памяти (возвращаем массив к исходному размеру)
        return {                            // Вернуть кортеж из:
                i                           // Индекса
                , comparisons               // Количества сравнений
                , occurrences_count         // Количества вхождений
                , duration_cast<microseconds>(finish - start).count() // Времени, затраченного на поиск
               }; // Конец возвращаемого кортежа
        
    } // Конец рассмотрения случая, когда ключ найден
    auto finish = steady_clock::now();  // Засечь время окончания выполнения функции
    // input = (T*)realloc(input, (size - 1)*sizeof(T)); // Повторная реаллокация памяти (возвращаем массив к исходному размеру)
    return {                            // Вернуть кортеж из:
            NOT_FOUND                   // Индекса
            , comparisons               // Количества сравнений
            , occurrences_count         // Количества вхождений
            , duration_cast<microseconds>(finish - start).count() // Времени, затраченного на поиск
           };                           // Конец возвращаемого кортежа
} // Конец функции поиска по алгоритму Т

template <typename T>                               // Шаблон для функции
tuple<int, uint, uint, uint> BAlgoSearch(           // Функция бинарного поиска
                                    T* input        // Входной массив
                                    , size_t size   // Размер входного массива
                                    , T key         // Искомый ключ
                                    ){              // Конец объявления ф-ции бинарного поиска
    PRINT_FUNC_NAME(__func__);                      // Печать названия функции
    steady_clock::time_point start = steady_clock::now(); // Засечь начальный момент времени
    uint comparisons = 0;                           // Обнулить счётчик сравнений
    uint occurrences_count = 0;                     // Обнулить счётчик количества вхождений
    size_t left = 0, right = size - 1;              // Задать границы для поиска
    while (left < right){                          // Пока левая граница не превосходит правую
        comparisons++;                              // Увеличить счётчик количества сравнений
        size_t middle = (left + right)/2;           // Вычислить индекс середины рассматриваемого отрезка
        if (input[middle] == key) {                 // Если серединой оказался искомый ключ
            auto finish = steady_clock::now();      // Засечь время окончания выполнения функции

            comparisons++;                          // Увеличить счётчик количества сравнений
            occurrences_count++;                // Увеличить счётчик количества вхождений

            for (int i = middle + 1; input[i] == key && i < size; ++i){ // Перебор части массива "правее" найденного ключа до момента, 
                                                                        // пока не встретится отличающийся элемент или не дойдём до конца массива
                occurrences_count++;            // Увеличить счётчик количества вхождений
            }                                   // Конец перебора для поиска ключей "правее" найденного

            for (int i = middle - 1; input[i] == key && i >= 0; --i){   // Перебор части массива "левее" найденного ключа до момента, 
                                                                        // пока не встретится отличающийся элемент или не дойдём до конца массива
                occurrences_count++;            // Увеличить счётчик количества вхождений
            }                                   // Конец перебора для поиска ключей "левее" найденного

            return {                            // Вернуть кортеж из:
                    middle                      // Индекса
                    , comparisons               // Количества сравнений
                    , occurrences_count         // Количества вхождений
                    , duration_cast<microseconds>(finish - start).count() // Времени, затраченного на поиск
                   }; // Конец возвращаемого кортежа
        } else {                                    // Если середина рассматриваемого отрезка не равна искомому ключу
            comparisons += 2;                       // Увеличить счётчик количества сравнений на 2 (условный оператор и сдвиг границ)
            if(input[middle] > key){                // Если центральное значение отрезка больше искомого ключа
                right = middle - 1;                 // Сдвинуть правую границу до середины рассматриваемого отрезка
            } else {                                // Если центральное значение отрезка меньше искомого ключа
                left = middle + 1;                  // Сдвинуть левую границу до середины рассматриваемого отрезка
            }                                       // Конец условного оператора сдвига границ
        }                                           // Конец условного оператора сравнения ключа с границами
    }                                               // Конец цикла сравнения границ
    comparisons++;                                  // Увеличить счётчик количества сравнений
    auto finish = steady_clock::now();              // Засечь время окончания выполнения функции

    return {                            // Вернуть кортеж из:
            NOT_FOUND                   // Индекса
            , comparisons               // Количества сравнений
            , occurrences_count         // Количества вхождений
            , duration_cast<microseconds>(finish - start).count() // Времени, затраченного на поиск
           }; // Конец возвращаемого кортежа
} // Конец функции поиска по алгоритму B

/* ============================================================================================================================
*                                К О Н Е Ц   О П Р Е Д Е Л Е Н И Я   Ф У Н К Ц И Й   П О И С К А
*  ============================================================================================================================ */