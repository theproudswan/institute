 /* =================================================
  *  Выполнил: Студент Лебедев И. И. 
  *  Группа: М3О-211Б-20
  *  Файл: test.h
  *  Содержание: Файл с набором тестов по заданиям
  *  Компилятор: g++ v. 10.2.1
  *  ================================================= */

#pragma once // Избежание проблемы двойного включения

#include "sort.h"       // Подключение заголовочного файла с функциями сортировок

#include <iostream>     // Библиотека для работы со стандартным потоком ввода/вывода
#include <tuple>        // Библиотека для работы с кортежами
#include <limits>       // Библиотека для использования numeric_limits<>::max()
#include <chrono>       // Библиотека для работы со временем

#define SIZE 10         // Определяем максимальный размер массива для печати
#define START 1'000     // Начальный размер массива для тестирования производительности
#define FINISH 1'000'000// Конечный размер массива для тестирования производительности
#define STEP 10         // Шаг, с которым будет переход к следующему элементу (Происходит умножение на этот шаг)

using namespace std; // Пространство имён std для использования функций стандартной библиотеки
/* * * * * * * * * * * * * * * * * * * * *
 *          ОБЪЯВЛЕНИЯ ФУНКЦИЙ
 * * * * * * * * * * * * * * * * * * * * */
void FirstTask();  // Функция для выполнения вервой части задания
void BestAndWorstCaseTest(); // Тестирование производительности в лучшем и худшем случаях
void SecondTask(); // Тестирование второй части задания

/* * * * * * * * * * * * * * * * * * * * *
 *          ОПРЕДЕЛЕНИЯ ФУНКЦИЙ
 * * * * * * * * * * * * * * * * * * * * */
void FirstTask() { // Функция для выполнения вервой части задания
  cout << "============== ПЕРВАЯ ЧАСТЬ ==============" << endl << endl;
  int * arr = new int[SIZE]; // Создание динамического массива для тестов
    uint comparisons; // Переменная для считывания кол-ва сравнений из возвращённого кортежа
    uint moves;       // Переменная для считывания кол-ва перестановок из возвращённого кортежа
    uint time;        // Переменная для считывания затраченного времени из возвращённого кортежа

  cout << "~~~ Шейкерная сортировка ~~~" << endl << endl;
  // Инициализация массива
  arr[0] = 12;
  arr[1] = 9;
  arr[2] = 3;
  arr[3] = 7;
  arr[4] = 14;
  arr[5] = 11;
  arr[6] = 6;
  arr[7] = 2;
  arr[8] = 10;
  arr[9] = 5;

  cout << "Исходный массив из " << SIZE <<" элементов:" << endl;

  for (int i = 0; i < SIZE; ++i) {   // Цикл по всем элементам массива
    cout << arr[i] << ' ';           // Вывести через пробел все элементы
  }                                  // Конец цикла перебора
  cout << "\n";                      // Вывод переноса строки

  cout << endl << "Матрица перестановок" << endl;

  tie(comparisons, moves, time) = ShakerSort(arr, SIZE); // Вывзов функции шейкерной сортировки и чтение возвращённого кортежа

  cout << endl << "Отсортированный массив:" << endl;

  for (int i = 0; i < SIZE; ++i) {   // Цикл по всем элементам массива
    cout << arr[i] << ' ';           // Вывести через пробел все элементы
  }                                  // Конец цикла перебора

  cout << endl << endl;
  cout << "Сравнений: " << comparisons << endl // Вывод полученной информации
       << "Пересылок: " << moves;
  cout << endl << endl << endl;

  cout << "~~~ Сортировка слиянием ~~~" << endl << endl;
  // Инициализация массива
  arr[0] = 12;
  arr[1] = 9;
  arr[2] = 3;
  arr[3] = 7;
  arr[4] = 14;
  arr[5] = 11;
  arr[6] = 6;
  arr[7] = 2;
  arr[8] = 10;
  arr[9] = 5;

  cout << "Исходный массив из " << SIZE <<" элементов:" << endl;

  for (int i = 0; i < SIZE; ++i) {   // Цикл по всем элементам массива
    cout << arr[i] << ' ';           // Вывести через пробел все элементы
  }                                  // Конец цикла перебора
  cout << "\n";                      // Вывод переноса строки

  cout << endl << "Матрица перестановок" << endl;
  tie(comparisons, moves) = MergeSort(arr, 0, 9, SIZE); // Вызов функции сортировки слиянием и чтение полученного кортежа

  cout << endl << "Отсортированный массив:" << endl;

  for (int i = 0; i < SIZE; ++i) {   // Цикл по всем элементам массива
    cout << arr[i] << ' ';           // Вывести через пробел все элементы
  }                                  // Конец цикла перебора

  cout << endl << endl;
  cout << "Сравнений: " << comparisons << endl // Вывод полученной информации
       << "Пересылок: " << moves;

  delete[] arr; // Высвобождение памяти из-под динамического массива
} // Конец функции, тестирующей первое задание


void BestAndWorstCaseTest(){ // Тестирование производительности в лучшем и худшем случаях
    cout << "============== Худший и лучший случай ==============" << endl << endl;

    size_t size = SIZE + 3; // Задать размер массива на 3 больше, чтобы печать не производилась
    uint comparisons; // Переменная для считывания кол-ва сравнений из возвращённого кортежа
    uint moves;       // Переменная для считывания кол-ва перестановок из возвращённого кортежа
    uint time;        // Переменная для считывания затраченного времени из возвращённого кортежа

    int* arr = new int [size]; // Создание динамического массива для тестов

    cout << "~~~ Худший случай: Шейкерная сортировка ~~~" << endl;
    for (int i = 0; i < size; ++i) // Цикл по всем элементам массива
        arr[i] = i;                // Заполнение массива по возрастанию
    cout << endl;
  cout << "Исходный массив из " << size <<" элементов:" << endl;

    for (int i = 0; i < size; ++i) {   // Цикл по всем элементам массива
      cout << arr[i] << ' ';           // Вывести через пробел все элементы
    }                                  // Конец цикла перебора
    cout << endl << endl;
    tie(comparisons, moves, time) = ShakerSort(arr, size); // Вывзов функции шейкерной сортировки и чтение возвращённого кортежа
    cout << "Сравнений: " << comparisons << endl     // Вывод полученной информации
         << "Пересылок: " << moves;

    cout << endl << endl;
    cout << "~~~ Лучший случай: Шейкерная сортировка ~~~" << endl;
    cout << endl;
    cout << "Исходный массив из " << size <<" элементов:" << endl;
    for (int i = 0; i < size; i++) {
        cout << arr[i] << ' ';
    }
    cout << endl;
    tie(comparisons, moves, time) = ShakerSort(arr, size); // Вывзов функции шейкерной сортировки и чтение возвращённого кортежа
    cout << endl;
    cout << "Сравнений: " << comparisons << endl     // Вывод полученной информации
         << "Пересылок: " << moves << endl << endl;
///////////////////////////////////////////////////////////////////////
    cout << "~~~ Худший случай: Сортировка слиянием ~~~" << endl;
    for (int i = 0; i < size; ++i) // Цикл по всем элементам массива
        arr[i] = i;                // Заполнение массива по возрастанию
    cout << endl;
    cout << "Исходный массив:" << endl;

    for (int i = 0; i < size; ++i) {   // Цикл по всем элементам массива
      cout << arr[i] << ' ';           // Вывести через пробел все элементы
    }                                  // Конец цикла перебора
    cout << endl << endl;
    tie(comparisons, moves) = MergeSort(arr, 0, size, size); // Вызов функции сортировки слиянием и чтение полученного кортежа
    cout << "Сравнений: " << comparisons << endl // Вывод полученной информации
         << "Пересылок: " << moves;

    cout << endl << endl;
    cout << "~~~ Лучший случай: Сортировка слиянием ~~~" << endl;
    cout << endl;
    cout << "Исходный массив:" << endl;
    for (int i = 0; i < size; ++i) {   // Цикл по всем элементам массива
      cout << arr[i] << ' ';           // Вывести через пробел все элементы
    }                                  // Конец цикла перебора
    cout << endl;
    tie(comparisons, moves) = MergeSort(arr, 0, size, size); // Вызов функции сортировки слиянием и чтение полученного кортежа
    cout << endl;
    cout << "Сравнений: " << comparisons << endl // Вывод полученной информации
         << "Пересылок: " << moves << endl;

    delete[] arr; // Высвобождение динамической памяти
} // Конец анализа худшего и лучшего случаев

void SecondTask(){ // Тестирование второй части задания
  cout << "============== ВТОРАЯ ЧАСТЬ ==============" << endl << endl;
  uint comparisons; // Переменная для считывания кол-ва сравнений из возвращённого кортежа
  uint moves;       // Переменная для считывания кол-ва перестановок из возвращённого кортежа
  uint time;        // Переменна ядля считывания затраченного времени из возвращённого кортежа
  for (int i = START; i <= FINISH; i *= STEP){ // Перебираем различные размерности массива
    int* arr = new int [i];      // Создаём массив новой размерности
    for (int j = 0; j < i; j++){ // Цикл для заполнения всего массива
      arr[j] = j;                // Заполнение по возрастанию
    }                            // Конец цикла заполнения
    cout << "Для массива из " << i << " элементов:" << endl << endl;
    cout << "Шейкерная сортировка: ";
    tie(comparisons, moves, time) = ShakerSort(arr, i); // Вывзов функции шейкерной сортировки и чтение возвращённого кортежа
    cout << comparisons << " сравн " << moves << " перес " << time << " мкс" << endl; // Вывод полученной информации
    
    for (int j = 0; j < i; j++){ // Цикл для заполнения всего массива
      arr[j] = j;                // Заполнение по возрастанию
    }                            // Конец цикла заполнения
    cout << "Сортировка слиянием: ";
    auto start = steady_clock::now();  // Засечь начальный момент времени
    tie(comparisons, moves) = MergeSort(arr, 0, i, i); // Вызов функции сортировки слиянием и чтение полученного кортежа
    auto finish = steady_clock::now(); // Засечь время окончания выполнения функции
    cout << comparisons << " сравн " << moves << " перес " << duration_cast<microseconds>(finish - start).count() << " мкс" << endl; // Вывод полученной информации
    delete[] arr; // Высвобождение памяти из-под текущего массива
    cout << endl << endl;
  } // Конец цикла создания различных массивов
} // Конец функции, тестирующей фторое задание