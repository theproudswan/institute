 /* =================================================
  *  Выполнил: Студент Лебедев И. И. 
  *  Группа: М3О-211Б-20
  *  Файл: test.h
  *  Содержание: Файл с процедурами сортировок (Шейкерная, слиянием)
  *  Компилятор: g++ v. 10.2.1
  *  ================================================= */

#pragma once // Избежание проблемы двойного включения

#include <iostream>     // Библиотека для работы со стандартным потоком ввода/вывода
#include <tuple>        // Библиотека для работы с кортежами
#include <limits>       // Библиотека для использования numeric_limits<>::max()
#include <chrono>       // Библиотека для работы со временем

#define SIZE 10         // Определяем максимальный размер массива для печати

using namespace std; // Пространство имён std для использования функций стандартной библиотеки
using namespace std::chrono; // Пространство имён std::chrono для использования функций работы со временем

/* * * * * * * * * * * * * * * * * * * * *
 *          ОБЪЯВЛЕНИЯ ФУНКЦИЙ
 * * * * * * * * * * * * * * * * * * * * */
template <typename T>   // Шаблон функции
  tuple<uint, uint, uint> ShakerSort(                   // Шейкерной сортировки (возвращает кортеж из кол-ва сравнений, кол-ва пересылок, затраченного времени)
                                      T* input          // Входной массив
                                      , size_t size);   // Размер входного массива

template <typename T> // Шаблон функции
  tuple<uint, uint> MergeSort(                  // Сортировка слиянием возвращает кортеж из кол-ва сравнений и кол-ва пересылок
                              T* input          // Входной массив для сортировки
                              , size_t left     // Левая граница диапазона
                              , size_t right    // Правая граница диапазона
                              , size_t size);   // Размер массива



/* * * * * * * * * * * * * * * * * * * * *
 *          ОПРЕДЕЛЕНИЯ ФУНКЦИЙ
 * * * * * * * * * * * * * * * * * * * * */


/* * * * * * * * * * * * * * * * * * * * *
 *          ШЕЙКЕРНАЯ СОРТИРОВКА
 * * * * * * * * * * * * * * * * * * * * */
template <typename T>   // Шаблон функции
  tuple<uint, uint, uint> ShakerSort(                   // Шейкерной сортировки (возвращает кортеж из кол-ва сравнений, кол-ва пересылок, затраченного времени)
                                      T* input          // Входной массив
                                      , size_t size) {  // Размер входного массива
    uint comparisons = 0; // Переменная для подсчёта кол-ва сравнений
    uint moves = 0;       // Переменная для подсчёта кол-ва пересылок

    steady_clock::time_point start = steady_clock::now(); // Засечь начальный момент времени

    int control = size - 1; // Установить контрольную границу
    int left = 0;           // Установить крайнюю левую границу
    int right = size - 1;   // Установить крайнюю правую границу

    do {                    // Делать, пока левая граница не совпадёт с правой
      comparisons++;        // Увеличить счётчик количества сравнений

      for (int i = left; i < right; i++) { // Цикл от левой границы до правой
        comparisons += 2;                  // Увеличить счётчик количества сравнений
        if (input[i] < input[i + 1]) {     // Если следующий элемент больше текущего
          swap(input[i], input[i + 1]);    // Обменять текущий и следующий элементы местами
          moves++;                         // Увеличить  счётчик пересылок
          control = i;                     // Присвоить контрольной границе номер текущего элемента
        }                                  // Конец "если"
      }                                    // Конец цикла справа налево

      if (size <= SIZE) {                  // Если размер массива не превоходит устанволенного в заголовке
        for (int i = 0; i < size; ++i) {   // Цикл по всем элементам массива
          cout << input[i] << ' ';         // Вывести через пробел все элементы
        }                                  // Конец цикла перебора
        cout << "\n";                      // Вывод переноса строки
      }                                    // Конец "если"

      comparisons++;                       // Увеличить счётчик количества сравнений
      right = control;                     // Присвоиьть правой границе значение контрольной

      for (int i = right; i > left; i--) { // Цикл от правой границы к левой
        comparisons += 2;                  // Увеличить счётчик количества сравнений
          if (input[i] > input[i - 1]) {   // Если i-й элемент больше i-1 элемента
            swap(input[i], input[i - 1]);  // Обменять их местами
            moves++;                       // Увеличить счётчик пересылок
            control = i;                   // Присвоить контрольной границе номер текущего элемента
          }                                // Конец "если"
      }                                    // Конец цикла справа налево
      comparisons++;                       // Увеличить счётчик количества сравнений
      left = control;                      // Присвоить левой границе значение контрольной 

      if (size <= SIZE) {                  // Если размер массива не превоходит устанволенного в заголовке
        for (int i = 0; i < size; ++i) {   // Цикл по всем элементам массива
          cout << input[i] << ' ';         // Вывести через пробел все элементы
        }                                  // Конец цикла перебора
        cout << "\n";                      // Вывод переноса строки
      }                                    // Конец "если"

    } while (left < right);                // Конец "пока"

    comparisons++;                         // Увеличить счётчик количества сравнений

    auto finish = steady_clock::now(); // Засечь время окончания выполнения функции

    return {            // Вернуть кортеж из:
            comparisons // Количества сравнений
            , moves     // Количества пересылок
            , duration_cast < microseconds > (finish - start).count() // Времени, затраченного на поиск
            };          // Конец возвращаемого кортежа
} // Конец функции ShakerSort()



/* * * * * * * * * * * * * * * * * * * * *
 *          ФУНКЦИЯ СЛИЯНИЯ
 * * * * * * * * * * * * * * * * * * * * */
template <typename T> // Шаблон функции
  tuple<uint, uint> Merge( // Слияние двух массивов, возвращает кортеж из кол-ва сравнений и кол-ва пересылок
                          T* input // Массив, "разделённый" на части
                          , size_t left // Левая граница
                          , size_t middle // Центр
                          , size_t right) { // Правая граница
    uint comparisons = 0; // Обнулить счётчик количества сравнений
    uint moves = 0;       // Обнулить счётчик количества пересылок

    int n1 = middle - left + 1; // Вычислить размер первого вспомогательного подмассива
    int n2 = right - middle;    // Вычислить размер второго вспомогательного подмассива

    T* tmp1 = new T[n1];        // Создать вспомогательный подмассив для левой части исходного массива
    T* tmp2 = new T[n2];        // Создать вспомогательный подмассив для првой части исходного массива

    for (int i = 0; i < n1; i++) // Цикл по левой половине исходного массива
      tmp1[i] = input[left + i]; // Инициализация первого подамссива
    for (int j = 0; j < n2; j++) // Цикл по правой половине исходного массива
      tmp2[j] = input[middle + 1 + j]; // Инициалиация второго подмассива
    comparisons += n1 + n2; // Записать количество произведённых сравнений в счётчик
    moves += n1 + n2;       // Записать количество произведённых перемещений в счётчик
    /* Поддержание текущего индекса вложенных массивов и основного массива */
    int i = 0       // Обнулить счётчик элементов для первого подмассива
        , j = 0     // Обнулить счётчик элементов для второго подмассива
        , k = left; // Присвоить счётчику цикла значение левой границы

    while (i < n1 && j < n2) { // Пока не достигнем конца tmp1 или tmp2
      comparisons += 3;        // Увеличить счётчик количества сравнений
      tmp1[i] > tmp2[j] ? (input[k] = tmp1[i], i++) : (input[k] = tmp2[j], j++); // Выбираем большее из элементов tmp1 и tmp2 и помещаем их в правильное положение в точке input [left..right]
      k++;     // Увеличить счётчик итераций
      moves++; // Увеличить счётчик перемещений
    }          // Конец "пока"

    comparisons += 2; // Увеличить счётчик количества сравнений

    // Когда кончаются элементы в tmp1 или tmp2, берём оставшиеся элементы и помещаем в input [left..right]
    while (i < n1) { // Если ещё не дошли до конца tmp1
      comparisons++; // Увеличить счётчик количества сравнений
      input[k] = tmp1[i]; // Дописать первый подмассив в исходный массив
      i++;                // Перейти к следующему элементу первого подмассива
      k++;                // Перейти к следующему элементу основного массива
      moves++;            // Увеличить счётчик пересылок
    }                     // Конец обработки первого подмассива

    comparisons++; // Увеличить счётчик количества сравнений

    while (j < n2) { // Если ещё не дошли до конца tmp2
      comparisons++; // Увеличить счётчик количества сравнений
      input[k] = tmp2[j]; // Дописать второй подмассив в исходный массив
      j++;                // Перейти к следующему элементу второго подмассива
      k++;                // Перейти к следующему элементу основного массива
      moves++;            // Увеличить счётчик пересылок
    }                     // Конец обработки второго подмассива

    delete[] tmp1;        // Высвобождаем память из-под первого подмассива
    delete[] tmp2;        // Высвобождаем память из-под второго подмассива

    return {            // Вернуть кортеж из:
            comparisons // Количества сравнений
            , moves     // Количества пересылок
            };          // Конец возвращаемого кортежа
} // Конец функции Merge()


/* * * * * * * * * * * * * * * * * * * * *
 *          СОРТИРОВКА СЛИЯНИЕМ
 * * * * * * * * * * * * * * * * * * * * */

template <typename T> // Шаблон функции
  tuple<uint, uint> MergeSort(                  // Сортировка слиянием возвращает кортеж из кол-ва сравнений и кол-ва пересылок
                              T* input          // Входной массив для сортировки
                              , size_t left     // Левая граница диапазона
                              , size_t right    // Правая граница диапазона
                              , size_t size) {  // Размер массива

    uint comparisons = 0; // Обнулить счётчик количества сравнений
    uint moves = 0;       // Обнулить счётчик количества пересылок

    comparisons++;       // Увеличить счётчик сравнений

    if (left >= right) { // Если left >= right, input[left..right] содержит не более 1 элемента,
      return {            // Вернуть кортеж из:
            comparisons // Количества сравнений
            , moves     // Количества пересылок
            };          // Конец возвращаемого кортежа
      // Так что он автоматически является отсортированным.
    } // Выполняется возврат из процедуры без каких-либо действий

    size_t middle = (left + right) / 2; // Вычислить середину диапазона left..right

    uint _comp, _mov; // Служебные переменные для чтения кортежа из ф-ции Merge

    MergeSort(input, left, middle, size); // Вызываем рекурсивно MergeSort для левой половины массива
    MergeSort(input, middle + 1, right, size); // Вызываем рекурсивно MergeSort для правой половины массива

    tie(_comp, _mov) = Merge(input, left, middle, right); // Объединяем полученные половины и читаем возвращённый кортеж
    comparisons += _comp; // Увеличиваем счётчик сравнений
    moves += _mov;        // Увеличиваем счётчик пересылок

    if (size <= SIZE) {                    // Если размер массива не превоходит устанволенного в заголовке
        for (int i = 0; i < size; ++i) {   // Цикл по всем элементам массива
          cout << input[i] << ' ';         // Вывести через пробел все элементы
        }                                  // Конец цикла перебора
        cout << "\n";                      // Вывод переноса строки
    }                                      // Конец "если"

    return {            // Вернуть кортеж из:
            comparisons // Количества сравнений
            , moves     // Количества пересылок
            };          // Конец возвращаемого кортежа
} // Конец функции MergeSort()
