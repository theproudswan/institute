#pragma once         // Для избежания проблемы двойного включения

#include <iostream>  // Библиотека для работы с входным и выходным потоками
#include <cmath>     // Библиотека для работы с математическими функциями
#include <chrono>    // Библиотека для вычисления времени работы
#include <string>    // Библиотека для работы со строками

using namespace std;         // Пространство имён std для использования функций стандартной библиотеки
using namespace std::chrono; // Пространство имён std::chrono для использования функций работы со временем

/* ============================================================================================================================
*                                         ОБЛАСТЬ ГЛОБАЛЬНЫХ КОНСТАНТ
*  ============================================================================================================================ */

#define RANDOM_RANGE 100 // Диапазон случайных чисел (от 0 до 99 включительно)
#define SAWTOOTH_HIGH 5  // Высота пилообразной последовательности минус 1
#define STAIRS_LENGTH 5  // Длина ступенчатой последовательности

/* ============================================================================================================================
*                                       КОНЕЦ ОБЛАСТИ ГЛОБАЛЬНЫХ КОНСТАНТ
*  ============================================================================================================================ */

/* ============================================================================================================================
*                                              ПРОТОТИПЫ ФУНКЦИИ ДЛЯ ГЕНЕРАЦИИ ПОСЛЕДОВАТЕЛЬНОСТЕЙ
*  ============================================================================================================================ */
template <typename T>                                            // Шаблон для функции с типом данных T
void IncreasingSequenceGeneration (                              // Функция, генерирующая возрастающую последовательность, принимает:
                                    T* result                    // Указатель на массив типа T для работы
                                    , const size_t size          // Размер последовательности
                                    , string& function_name      // Строку для записи названия исполняемой функции
                                    );

template <typename T>                                            // Шаблон для функции с типом данных T
void DescendingSequenceGeneration (                              // Функция, генерирующая убывающую последовательность, принимает:
                                    T* result                    // Указатель на массив типа T для работы
                                    , const size_t size          // Размер последовательности
                                    , string& function_name      // Строку для записи названия исполняемой функции
                                );

template <typename T>                                            // Шаблон для функции с типом данных T
void SinusSequenceGeneration (                                   // Функция, генерирующая синусоидальную последовательность, принимает:
                                    T* result                    // Указатель на массив типа T для работы
                                    , const size_t size          // Размер последовательности
                                    , string& function_name      // Строку для записи названия исполняемой функции
                                );
template <typename T>                                            // Шаблон для функции с типом данных T
void RandomSequenceGeneration (                                  // Функция, генерирующая случайную последовательность, принимает:
                                    T* result                    // Указатель на массив типа T для работы
                                    , const size_t size          // Размер последовательности
                                    , string& function_name      // Строку для записи названия исполняемой функции
                                );
template <typename T>                                            // Шаблон для функции с типом данных T
void SawtoothSequenceGeneration (                                // Функция, генерирующая пилообразную последовательность, принимает:
                                    T* result                    // Указатель на массив типа T для работы
                                    , const size_t size          // Размер последовательности
                                    , string& function_name      // Строку для записи названия исполняемой функции
                                );
template <typename T>                                            // Шаблон для функции с типом данных T
void StairsSequenceGeneration (                                  // Функция, генерирующая ступенчатую последовательность, принимает:
                                    T* result                    // Указатель на массив типа T для работы
                                    , const size_t size          // Размер последовательности
                                    , string& function_name      // Строку для записи названия исполняемой функции
                                );                           
  
template <typename T>                                            // Шаблон для функции с типом данных T
void QuasiRandomSequenceGeneration (                             // Функция, генерирующая квази-случайную последовательность, принимает:
                                    T* result                    // Указатель на массив типа T для работы
                                    , const size_t size          // Размер последовательности
                                    , string& function_name      // Строку для записи названия исполняемой функции
                                    );
   
/* ============================================================================================================================
*                                          КОНЕЦ ПРОТОТИПОВ ФУНКЦИЙ ДЛЯ ГЕНЕРАЦИИ ПОСЛЕДОВАТЕЛЬНОСТЕЙ
*  ============================================================================================================================ */

/* ============================================================================================================================
*                                              ОПРЕДЕЛЕНИЕ ФУНКЦИЙ ДЛЯ ГЕНЕРАЦИИ ПОСЛЕДОВАТЕЛЬНОСТЕЙ
*  ============================================================================================================================ */

template <typename T>                                            // Шаблон для функции с типом данных T
void IncreasingSequenceGeneration (                              // Функция, генерирующая возрастающую последовательность, принимает:
                                    T* result                    // Указатель на массив типа T для работы
                                    , const size_t size          // Размер последовательности
                                    , string& function_name      // Строку для записи названия исполняемой функции
                                    ){                           // Начало функции
    function_name = __func__;                                    // Запись названия имени исполняемой функции
    steady_clock::time_point start = steady_clock::now();        // Засечь начальный момент времени
    //for(size_t i = 0; i < size; ++i){                            // Цикл по i для перебора всего массива
    for(int i = size - 1; i >= 0; i--){                            // Цикл по i для перебора всего массива

         result[i] = i;                                           // Присваивание i-му элементу последовательности значения больше, чем i - 1
         //cout << result[i] << ' ';
    }                                                            // Конец цикла по i
    auto finish = steady_clock::now();                           // Засечь время окончания выполнения функции
    cout << "Возрастающая последовательность: "
         << duration_cast<microseconds>(finish - start).count()  // Вывести, сколько времени потребовалось для выполнения функции
         << " mcs" << endl;
}                                                                // Конец функции, генерирующей возрастающую последовательность


template <typename T>                                            // Шаблон для функции с типом данных T
void DescendingSequenceGeneration (                              // Функция, генерирующая убывающую последовательность, принимает:
                                    T* result                    // Указатель на массив типа T для работы
                                    , const size_t size          // Размер последовательности
                                    , string& function_name      // Строку для записи названия исполняемой функции
                                    ){                           // Начало функции
    function_name = __func__;                                    // Запись названия имени исполняемой функции
    steady_clock::time_point start = steady_clock::now();        // Засечь начальный момент времени
    for(size_t i = 0; i < size; ++i){                            // Цикл по i для перебора всего массива
        result[i] = size - i - 1;                                // Присваивание i-му элементу последовательности значения меньше, чем i - 1
    }                                                            // Конец цикла по i  
    auto finish = steady_clock::now();                           // Засечь время окончания выполнения функции
    cout << "Убывающая последовательность: "
         << duration_cast<microseconds>(finish - start).count()  // Вывести, сколько времени потребовалось для выполнения функции
         << " mcs" << endl;
}                                                                // Конец функции, генерирующей убывающую последовательность

template <typename T>                                            // Шаблон для функции с типом данных T
void SinusSequenceGeneration (                                   // Функция, генерирующая синусоидальную последовательность, принимает:
                                    T* result                    // Указатель на массив типа T для работы
                                    , const size_t size          // Размер последовательности
                                    , string& function_name      // Строку для записи названия исполняемой функции
                                    ){                           // Начало функции
    function_name = __func__;                                    // Запись названия имени исполняемой функции
    steady_clock::time_point start = steady_clock::now();        // Засечь начальный момент времени
    for(size_t i = 0; i < size; ++i){                            // Цикл по i для перебора всего массива
        result[i] = sin(i) * 10;                                 // Присваивание i-му элементу последовательности значения синуса i
    }                                                            // Конец цикла по i
    auto finish = steady_clock::now();                           // Засечь время окончания выполнения функции
    cout << "Синусоидальная последовательность: "
         << duration_cast<microseconds>(finish - start).count()  // Вывести, сколько времени потребовалось для выполнения функции
         << " mcs" << endl;
}                                                                // Конец функции, генерирующей синусоидальную последовательность

template <typename T>                                            // Шаблон для функции с типом данных T
void RandomSequenceGeneration (                                  // Функция, генерирующая случайную последовательность, принимает:
                                    T* result                    // Указатель на массив типа T для работы
                                    , const size_t size          // Размер последовательности
                                    , string& function_name      // Строку для записи названия исполняемой функции
                                    ){                           // Начало функции
    function_name = __func__;                                    // Запись названия имени исполняемой функции
    steady_clock::time_point start = steady_clock::now();        // Засечь начальный момент времени
    for(size_t i = 0; i < size; ++i){                            // Цикл по i для перебора всего массива
        result[i] = rand() % RANDOM_RANGE;                       // Присваивание i-му элементу последовательности случайного значения от 0 до (RANDOM_RANGE - 1)
    }                                                            // Конец цикла по i
    auto finish = steady_clock::now();                           // Засечь время окончания выполнения функции
    cout << "Случайное заполнение: "
         << duration_cast<microseconds>(finish - start).count()  // Вывести, сколько времени потребовалось для выполнения функции
         << " mcs" << endl;
}                                                                // Конец функции, генерирующей случайную последовательность

template <typename T>                                            // Шаблон для функции с типом данных T
void SawtoothSequenceGeneration (                                // Функция, генерирующая пилообразную последовательность, принимает:
                                    T* result                    // Указатель на массив типа T для работы
                                    , const size_t size          // Размер последовательности
                                    , string& function_name      // Строку для записи названия исполняемой функции
                                    ){                           // Начало функции
    function_name = __func__;                                    // Запись названия имени исполняемой функции
    steady_clock::time_point start = steady_clock::now();        // Засечь начальный момент времени
    for(size_t i = 0; i < size; ++i){                            // Цикл по i для перебора всего массива
        result[i] = i % SAWTOOTH_HIGH;                           // Присваивание i-му элементу последовательности значения по формуле i % SAWTOOTH_HIGH
    }                                                            // Конец цикла по i
    auto finish = steady_clock::now();                           // Засечь время окончания выполнения функции
    cout << "Пилообразная последовательность: "
         << duration_cast<microseconds>(finish - start).count()  // Вывести, сколько времени потребовалось для выполнения функции
         << " mcs" << endl;
}                                                                // Конец функции, генерирующей пилообразную последовательность

template <typename T>                                            // Шаблон для функции с типом данных T
void StairsSequenceGeneration (                                  // Функция, генерирующая ступенчатую последовательность, принимает:
                                    T* result                    // Указатель на массив типа T для работы
                                    , const size_t size          // Размер последовательности
                                    , string& function_name      // Строку для записи названия исполняемой функции
                                    ){                           // Начало функции
    function_name = __func__;                                    // Запись названия имени исполняемой функции
    steady_clock::time_point start = steady_clock::now();        // Засечь начальный момент времени
    for(size_t i = 0; i < size; ++i){                            // Цикл по i для перебора всего массива
        result[i] = i / STAIRS_LENGTH;                           // Присваивание i-му элементу последовательности значения по формуле i / SAWTOOTH_HIGH
    }                                                            // Конец цикла по i
    auto finish = steady_clock::now();                           // Засечь время окончания выполнения функции
    cout << "Последовательность лестницей: "
         << duration_cast<microseconds>(finish - start).count()  // Вывести, сколько времени потребовалось для выполнения функции
         << " mcs" << endl;
}                                                                // Конец функции, генерирующей ступенчатую последовательность

template <typename T>                                            // Шаблон для функции с типом данных T
void QuasiRandomSequenceGeneration (                                  // Функция, генерирующая квази-случайную последовательность, принимает:
                                    T* result                    // Указатель на массив типа T для работы
                                    , const size_t size          // Размер последовательности
                                    , string& function_name      // Строку для записи названия исполняемой функции
                                    ){                           // Начало функции
    function_name = __func__;                                    // Запись названия имени исполняемой функции
    steady_clock::time_point start = steady_clock::now();        // Засечь начальный момент времени
    for(size_t i = 0; i < size; ++i){                            // Цикл по i для перебора всего массива
        result[i] = i / STAIRS_LENGTH + rand() % 5;              // Присваивание i-му элементу последовательности значения по формуле i / SAWTOOTH_HIGH + случайное число от 0 до 5
    }                                                            // Конец цикла по i
    auto finish = steady_clock::now();                           // Засечь время окончания выполнения функции
    cout << "Квазислучайная последовательность: "
         << duration_cast<microseconds>(finish - start).count()  // Вывести, сколько времени потребовалось для выполнения функции
         << " mcs" << endl;
}                                                                // Конец функции, генерирующей квази-случайную последовательность
/* ============================================================================================================================
*                                         КОНЕЦ ОПРЕДЕЛЕНИЯ ФУНКЦИЙ ДЛЯ ГЕНЕРАЦИИ ПОСЛЕДОВАТЕЛЬНОСТЕЙ
*  ============================================================================================================================ */