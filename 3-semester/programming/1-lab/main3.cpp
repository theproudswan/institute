/* =================================================
*  Выполнил: Студент Лебедев И. И. 
*  Группа: М3О-211Б-20
*  ================================================= */

#include "functions.h" // Подключение файла с прототипами функций
                       // Глобальные константы RANDOM_RANGE, SAWTOOTH_HIGH и STAIRS_LENGTH
                       // Зарезервированы в нём

#include <iostream>  // Библиотека для работы с входным и выходным потоками
#include <cmath>     // Библиотека для работы с математическими функциями
#include <string>    // Библиотека для работы со строками

/* ============================================================================================================================
*                                         ОБЛАСТЬ ГЛОБАЛЬНЫХ КОНСТАНТ
*  ============================================================================================================================ */

#define FUNCTIONS_COUNT  7   // Количество функций (вариантов последовательности)
#define SIZE_LOWER_BOUND 100 // Минимальное количество элементов, при котором будет производиться запись в файл
#define SIZE_UPPER_BOUND 200 // Максимальное количество элементов, при котором будет производиться запись в файл

/* ============================================================================================================================
*                                       КОНЕЦ ОБЛАСТИ ГЛОБАЛЬНЫХ КОНСТАНТ
*  ============================================================================================================================ */

typedef void (*MENU_INT)(int*, const size_t, string&);       // Создание прототипа для использования массива указателей на целочисленные функции
typedef void (*MENU_FLOAT)(float*, const size_t, string&);   // Создание прототипа для использования массива указателей на функции с плавающей точкой

int main(){            // Главная исполняемая функция
    srand(time(NULL)); // Обнуление "зерна" времени для генерации случайных чисел
    size_t size;       // Объявление переменной (беззнаковая, целая), в которой будет храниться размер массива
    cout << "Введите размер массива: "; // Вывод с помощью стандратного потока вывода сообщения о вводе размера массива
    cin >> size;       // Ввод с помощью стандартного потока ввода объявленного размера
    
    bool out = (size >= SIZE_LOWER_BOUND && size <= SIZE_UPPER_BOUND); // Переменная-флаг для вывода в файл будет истинна, если количество элементов от 100 до 200. В противном случае - ложна

    if (out){                                                       // Если флаг out установлен на печать в файл
        cout << "Будет произведена запись в файл" << endl;          // Вывести информационное сообщение о печати в файл
    } else {                                                        // Если вывод не должен производиться
        cout << "Запись в файл произведена не будет" << endl;       // Вывести информационное сообщение об отсутствии печати в файл
    }                                                               // Конец условного оператора для информирования пользователя о наличии/отсутствии печати в файл

    cout << endl;      // Вывод  с помощью стандартного потока вывода переноса строки

    MENU_INT Int_Sequences[] = {                                    // Создание массива указателей на функции
                            IncreasingSequenceGeneration,           // Возрастающая последовательность
                            DescendingSequenceGeneration,           // Убывающая последовательность
                            RandomSequenceGeneration,               // Случайная последовательность
                            SinusSequenceGeneration,                // Синусоидальная последовательность        
                            SawtoothSequenceGeneration,             // Пилообразная последовательность
                            StairsSequenceGeneration,               // Ступенчатая последовательность
                            QuasiRandomSequenceGeneration           // Квази-случайная последовательность
                            };

    MENU_FLOAT Float_Sequences[] = {                                // Создание массива указателей на функции
                            IncreasingSequenceGeneration,           // Возрастающая последовательность
                            DescendingSequenceGeneration,           // Убывающая последовательность
                            RandomSequenceGeneration,               // Случайная последовательность
                            SinusSequenceGeneration,                // Синусоидальная последовательность        
                            SawtoothSequenceGeneration,             // Пилообразная последовательность
                            StairsSequenceGeneration,               // Ступенчатая последовательность
                            QuasiRandomSequenceGeneration           // Квази-случайная последовательность
                            };

    /* ============================================================================================================================
    *                                                  ЦЕЛОЧИСЛЕННЫЕ ПОСЛЕДОВАТЕЛЬНОСТИ
    *  ============================================================================================================================ */
    cout << "=====================      ЦЕЛОЧИСЛЕННЫЕ ПОСЛЕДОВАТЕЛЬНОСТИ       =====================" << endl;
    int *arr_int = new int [size];                      // Создание указателя на область в памяти для работы с целочисленным массивом
    for (unsigned short int i = 0; i < FUNCTIONS_COUNT; ++i){ // Перебор всего массива указателей на функции
        string func_name;                               // Переменная будет хранить в себе название вызываемой функции
        Int_Sequences[i](                               // Вызов соответствующей функции для генерации последовательности со следующими аргументами:
                            arr_int                     // Массив для записи последовательности
                            , size                      // Размер массива
                            , func_name);               // Строка для записи с именем функции
        if (out){                                       // Если необходимо записывать массив в файл
            string filename = "int_" + func_name + ".txt"; // Создание строки с названием выходного файла для текущей последовательности
            FILE* output;                               // Объявление выходного файла
            output = fopen(filename.c_str(), "w");      // Открытие выходного файла в режиме записи
            if(output){                                 // Если файл удалось открыть/создать
                for(size_t j = 0; j < size; ++j){       // Перебор всех элементов сформированного массива
                    fprintf(output, "%d\n", arr_int[j]);// Занесение текущего значения ячейки массива в выходной файл
                }                                       // Конец перебора элементов последовательности
                fclose(output);                         // Закрытие выходного файла
            } else {                                    // Если файл не удалось открыть
                cerr << "Невозможно открыть файл " << filename << endl; // Вывести сообщение об ошибке
            }                                           // Конец условного оператора проверки доступности работы с файлом
        }                                               // Конец условного оператора для вывода последовательности в файл
    }                                                   // Конец перебора массива указателей на функции
    delete[] arr_int;                                   // Высвобождение памяти из-под динамического массива целых чисел

    /* ============================================================================================================================
    *                                             ПОСЛЕДОВАТЕЛЬНОСТИ С ПЛАВАЮЩЕЙ ТОЧКОЙ
    *  ============================================================================================================================ */
    cout << endl << endl;
    cout << "=====================      ПОСЛЕДОВАТЕЛЬНОСТИ С ПЛАВАЮЩЕЙ ТОЧКОЙ       ================" << endl;
    float *arr_float = new float [size];                // Создание указателя на область в памяти для работы с целочисленным массивом
    for (unsigned short int i = 0; i < FUNCTIONS_COUNT; ++i){ // Перебор всего массива указателей на функции
        string func_name;                               // Переменная будет хранить в себе название вызываемой функции
        Float_Sequences[i](                             // Вызов соответствующей функции для генерации последовательности со следующими аргументами:
                            arr_float                   // Массив для записи последовательности
                            , size                      // Размер массива
                            , func_name);               // Строка для записи с именем функции
        if (out){                                       // Если необходимо записывать массив в файл
            string filename = "float_" + func_name + ".txt"; // Создание строки с названием выходного файла для текущей последовательности
            FILE* output;                               // Объявление выходного файла
            output = fopen(filename.c_str(), "w");      // Открытие выходного файла в режиме записи
            if(output){                                 // Если файл удалось открыть/создать
                for(size_t j = 0; j < size; ++j){       // Перебор всех элементов сформированного массива
                    fprintf(output, "%f\n", arr_float[j]);// Занесение текущего значения ячейки массива в выходной файл
                }                                       // Конец перебора элементов последовательности
                fclose(output);                         // Закрытие выходного файла
            } else {                                    // Если файл не удалось открыть
                cerr << "Невозможно открыть файл " << filename << endl; // Вывести сообщение об ошибке
            }                                           // Конец условного оператора проверки доступности работы с файлом
        }                                               // Конец условного оператора для вывода последовательности в файл
    }                                                   // Конец перебора массива указателей на функции
    delete[] arr_float;                                 // Высвобождение памяти из-под динамического массива чисел с плавающей точкой
    return 0;                                           // Программа возвращает 0 - корректное завершение работы
}                                                       // Конец главной функции
