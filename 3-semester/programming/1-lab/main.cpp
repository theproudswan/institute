#include <iostream>  // Библиотека для работы с входным и выходным потоками
#include <cmath>     // Библиотека для работы с математическими функциями
#include <chrono>    // Библиотека для вычисления времени работы

/* ============================================================================================================================
*                                                  ЦЕЛОЧИСЛЕННЫЕ ПОСЛЕДОВАТЕЛЬНОСТИ
*  ============================================================================================================================ */
#define INT_INCREASING_FILE_NAME "int_inc_output.txt"       // Название выходного файла для возрастающей последовательности
#define INT_DESCENDING_FILE_NAME "int_dec_output.txt"       // Название выходного файла для убывающей последовательности
#define INT_RANDOM_FILE_NAME "int_rand_output.txt"          // Название выходного файла для случайной последовательности
#define INT_SINUS_FILE_NAME "int_sin_output.txt"            // Название выходного файла для синусоидальной последовательности
#define INT_SAWTOOTH_FILE_NAME "int_sawtooth_output.txt"    // Название выходного файла для пилообразной последовательности
#define INT_STAIRS_FILE_NAME "int_stairs_output.txt"        // Название выходного файла для ступенчатой последовательности
#define INT_QUASI_FILE_NAME "int_quasi_output.txt"          // Название выходного файла для ступенчатой последовательности

/* ============================================================================================================================
*                                             ПОСЛЕДОВАТЕЛЬНОСТИ С ПЛАВАЮЩЕЙ ТОЧКОЙ
*  ============================================================================================================================ */
#define FLOAT_INCREASING_FILE_NAME "float_inc_output.txt"       // Название выходного файла для возрастающей последовательности
#define FLOAT_DESCENDING_FILE_NAME "float_dec_output.txt"       // Название выходного файла для убывающей последовательности
#define FLOAT_RANDOM_FILE_NAME "float_rand_output.txt"          // Название выходного файла для случайной последовательности
#define FLOAT_SINUS_FILE_NAME "float_sin_output.txt"            // Название выходного файла для синусоидальной последовательности
#define FLOAT_SAWTOOTH_FILE_NAME "float_sawtooth_output.txt"    // Название выходного файла для пилообразной последовательности
#define FLOAT_STAIRS_FILE_NAME "float_stairs_output.txt"        // Название выходного файла для ступенчатой последовательности
#define FLOAT_QUASI_FILE_NAME "float_quasi_output.txt"          // Название выходного файла для ступенчатой последовательности



#define RANDOM_RANGE 100 // Диапазон случайных чисел (от 0 до 99 включительно)
#define SAWTOOTH_HIGH 5  // Высота пилообразной последовательности минус 1
#define STAIRS_LENGTH 5  // Длина ступенчатой последовательности

using namespace std;         // Пространство имён std для использования функций стандартной библиотеки
using namespace std::chrono; // Пространство имён std::chrono для использования функций работы со временем


/* ============================================================================================================================
*                                                  ЦЕЛОЧИСЛЕННЫЕ ПОСЛЕДОВАТЕЛЬНОСТИ
*  ============================================================================================================================ */
int* IncreasingSequenceGeneration(const size_t size){    // Функция, принимает размер создаваемой возрастающей последовательности и возвращает указатель на сформированную 
    steady_clock::time_point start = steady_clock::now(); // Засечь начальный момент времени
    int* result = new int [size];                          // Создание итогового массива размера size
    for(size_t i = 0; i < size; ++i){                  // Цикл по i для перебора всего массива
        result[i] = i;                           // Присваивание соответствующего значения по возрастанию ячейке массива с индексом i
    }                                                  // Конец цикла по i
    auto finish = steady_clock::now();                 // Засечь время окончания выполнения функции
    cout << "Возрастающая последовательность: "
         << duration_cast<microseconds>(finish - start).count()   // Вывести, сколько времени потребовалось для выполнения функции
         << " mcs" << endl;
    return result;                                     // Возвращение сформированного массива
}
int* DescendingSequenceGeneration(const size_t size){    // Функция, принимает размер создаваемой убывающей последовательности и возвращает указатель на сформированную 
    steady_clock::time_point start = steady_clock::now(); // Засечь начальный момент времени
    int* result = new int [size];                          // Создание итогового массива размера size
    for(size_t i = 0; i < size; ++i){                  // Цикл по i для перебора всего массива
        result[i] = size - i - 1;                // Присваивание соответствующего значения по убыванию ячейке массива с индексом i
    }                                                  // Конец цикла по i  
    auto finish = steady_clock::now();                 // Засечь время окончания выполнения функции
    cout << "Убывающая последовательность: "
         << duration_cast<microseconds>(finish - start).count()   // Вывести, сколько времени потребовалось для выполнения функции
         << " mcs" << endl;
    return result;                                     // Возвращение сформированного массива
}
int* RandomGeneration(const size_t size){                // Функция, принимает размер создаваемой случайной последовательности и возвращает указатель на сформированную 
    steady_clock::time_point start = steady_clock::now(); // Засечь начальный момент времени
    int* result = new int [size];                          // Создание итогового массива размера size
    for(size_t i = 0; i < size; ++i){                  // Цикл по i для перебора всего массива
        result[i] = rand() % RANDOM_RANGE;       // Присваивание соответствующего случайного значения ячейке массива с индексом i
    }                                                  // Конец цикла по i
    auto finish = steady_clock::now();                 // Засечь время окончания выполнения функции
    cout << "Случайное заполнение: "
         << duration_cast<microseconds>(finish - start).count()   // Вывести, сколько времени потребовалось для выполнения функции
         << " mcs" << endl;
    return result;                                     // Возвращение сформированного массива
}
int* SinusSequenceGeneration(const size_t size){         // Функция, принимает размер создаваемой синусоидальной последовательности и возвращает указатель на сформированную 
    steady_clock::time_point start = steady_clock::now(); // Засечь начальный момент времени
    int* result = new int [size];                          // Создание итогового массива размера size
    for(size_t i = 0; i < size; ++i){                  // Цикл по i для перебора всего массива
        result[i] = sin(i) * 10;                       // Присваивание соответствующего значения синуса i ячейке массива с индексом i
    }                                                  // Конец цикла по i
    auto finish = steady_clock::now();                 // Засечь время окончания выполнения функции
    cout << "Синусоидальная последовательность: "
         << duration_cast<microseconds>(finish - start).count()   // Вывести, сколько времени потребовалось для выполнения функции
         << " mcs" << endl;
    return result;                                     // Возвращение сформированного массива
}
int* SawtoothSequenceGeneration(const size_t size){      // Функция, принимает размер создаваемой пилообразной последовательности и возвращает указатель на сформированную 
    steady_clock::time_point start = steady_clock::now(); // Засечь начальный момент времени
    int* result = new int [size];                          // Создание итогового массива размера size
    for(size_t i = 0; i < size; ++i){                  // Цикл по i для перебора всего массива
        result[i] = i % SAWTOOTH_HIGH;         // Присваивание соответствующего значения пилообразной последовательности по формуле i % SAWTOOTH_HIGH ячейке массива с индексом i
    }                                                  // Конец цикла по i
    auto finish = steady_clock::now();                 // Засечь время окончания выполнения функции
    cout << "Пилообразная последовательность: "
         << duration_cast<microseconds>(finish - start).count()   // Вывести, сколько времени потребовалось для выполнения функции
         << " mcs" << endl;
    return result;                                     // Возвращение сформированного массива
}
int* StairsSequenceGeneration(const size_t size){        // Функция, принимает размер создаваемой ступенчатой последовательности и возвращает указатель на сформированную 
    steady_clock::time_point start = steady_clock::now(); // Засечь начальный момент времени
    int* result = new int [size];                          // Создание итогового массива размера size
    for(size_t i = 0; i < size; ++i){                  // Цикл по i для перебора всего массива
        result[i] = i / STAIRS_LENGTH;         // Присваивание соответствующего значения ступенчатой последовательности по формуле i / SAWTOOTH_HIGH ячейке массива с индексом i
    }                                                  // Конец цикла по i
    auto finish = steady_clock::now();                 // Засечь время окончания выполнения функции
    cout << "Последовательность лестницей: "
         << duration_cast<microseconds>(finish - start).count()   // Вывести, сколько времени потребовалось для выполнения функции
         << " mcs" << endl;
    return result;                                     // Возвращение сформированного массива
}
int* QuasiRandomSequenceGeneration(const size_t size){   // Функция, принимает размер создаваемой ступенчатой последовательности и возвращает указатель на сформированную 
    steady_clock::time_point start = steady_clock::now(); // Засечь начальный момент времени
    int* result = new int [size];                          // Создание итогового массива размера size
    for(size_t i = 0; i < size; ++i){                  // Цикл по i для перебора всего массива
        result[i] = i / STAIRS_LENGTH + rand() % 5;    // Присваивание соответствующего значения ступенчатой последовательности по формуле i / SAWTOOTH_HIGH ячейке массива с индексом i
    }                                                  // Конец цикла по i
    auto finish = steady_clock::now();                 // Засечь время окончания выполнения функции
    cout << "Квазислучайная последовательность: "
         << duration_cast<microseconds>(finish - start).count()   // Вывести, сколько времени потребовалось для выполнения функции
         << " mcs" << endl;
    return result;                                     // Возвращение сформированного массива
}


/* ============================================================================================================================
*                                             ПОСЛЕДОВАТЕЛЬНОСТИ С ПЛАВАЮЩЕЙ ТОЧКОЙ
*  ============================================================================================================================ */
float* FloatIncreasingSequenceGeneration(const size_t size){    // Функция, принимает размер создаваемой возрастающей последовательности и возвращает указатель на сформированную 
    steady_clock::time_point start = steady_clock::now(); // Засечь начальный момент времени
    float* result = new float [size];                          // Создание итогового массива размера size
    for(size_t i = 0; i < size; ++i){                  // Цикл по i для перебора всего массива
        result[i] = i * 1.5;                                 // Присваивание соответствующего значения по возрастанию ячейке массива с индексом i
    }                                                  // Конец цикла по i
    auto finish = steady_clock::now();                 // Засечь время окончания выполнения функции
    cout << "Возрастающая последовательность: "
         << duration_cast<microseconds>(finish - start).count()   // Вывести, сколько времени потребовалось для выполнения функции
         << " mcs" << endl;
    return result;                                     // Возвращение сформированного массива
}
float* FloatDescendingSequenceGeneration(const size_t size){    // Функция, принимает размер создаваемой убывающей последовательности и возвращает указатель на сформированную 
    steady_clock::time_point start = steady_clock::now(); // Засечь начальный момент времени
    float* result = new float [size];                          // Создание итогового массива размера size
    for(size_t i = 0; i < size; ++i){                  // Цикл по i для перебора всего массива
        result[i] = (size - i - 1)*1.5;                // Присваивание соответствующего значения по убыванию ячейке массива с индексом i
    }                                                  // Конец цикла по i  
    auto finish = steady_clock::now();                 // Засечь время окончания выполнения функции
    cout << "Убывающая последовательность: "
         << duration_cast<microseconds>(finish - start).count()   // Вывести, сколько времени потребовалось для выполнения функции
         << " mcs" << endl;
    return result;                                     // Возвращение сформированного массива
}
float* FloatRandomGeneration(const size_t size){                // Функция, принимает размер создаваемой случайной последовательности и возвращает указатель на сформированную 
    steady_clock::time_point start = steady_clock::now(); // Засечь начальный момент времени
    float* result = new float [size];                          // Создание итогового массива размера size
    for(size_t i = 0; i < size; ++i){                  // Цикл по i для перебора всего массива
        result[i] = (rand() % RANDOM_RANGE)*1.5;       // Присваивание соответствующего случайного значения ячейке массива с индексом i
    }                                                  // Конец цикла по i
    auto finish = steady_clock::now();                 // Засечь время окончания выполнения функции
    cout << "Случайное заполнение: "
         << duration_cast<microseconds>(finish - start).count()   // Вывести, сколько времени потребовалось для выполнения функции
         << " mcs" << endl;
    return result;                                     // Возвращение сформированного массива
}
float* FloatSinusSequenceGeneration(const size_t size){         // Функция, принимает размер создаваемой синусоидальной последовательности и возвращает указатель на сформированную 
    steady_clock::time_point start = steady_clock::now(); // Засечь начальный момент времени
    float* result = new float [size];                          // Создание итогового массива размера size
    for(size_t i = 0; i < size; ++i){                  // Цикл по i для перебора всего массива
        result[i] = sin(i) * 10;                       // Присваивание соответствующего значения синуса i ячейке массива с индексом i
    }                                                  // Конец цикла по i
    auto finish = steady_clock::now();                 // Засечь время окончания выполнения функции
    cout << "Синусоидальная последовательность: "
         << duration_cast<microseconds>(finish - start).count()   // Вывести, сколько времени потребовалось для выполнения функции
         << " mcs" << endl;
    return result;                                     // Возвращение сформированного массива
}
float* FloatSawtoothSequenceGeneration(const size_t size){      // Функция, принимает размер создаваемой пилообразной последовательности и возвращает указатель на сформированную 
    steady_clock::time_point start = steady_clock::now(); // Засечь начальный момент времени
    float* result = new float [size];                          // Создание итогового массива размера size
    for(size_t i = 0; i < size; ++i){                  // Цикл по i для перебора всего массива
        result[i] = (i % SAWTOOTH_HIGH) * 1.5;         // Присваивание соответствующего значения пилообразной последовательности по формуле i % SAWTOOTH_HIGH ячейке массива с индексом i
    }                                                  // Конец цикла по i
    auto finish = steady_clock::now();                 // Засечь время окончания выполнения функции
    cout << "Пилообразная последовательность: "
         << duration_cast<microseconds>(finish - start).count()   // Вывести, сколько времени потребовалось для выполнения функции
         << " mcs" << endl;
    return result;                                     // Возвращение сформированного массива
}
float* FloatStairsSequenceGeneration(const size_t size){        // Функция, принимает размер создаваемой ступенчатой последовательности и возвращает указатель на сформированную 
    steady_clock::time_point start = steady_clock::now(); // Засечь начальный момент времени
    float* result = new float [size];                          // Создание итогового массива размера size
    for(size_t i = 0; i < size; ++i){                  // Цикл по i для перебора всего массива
        result[i] = (i / STAIRS_LENGTH) * 1.5;         // Присваивание соответствующего значения ступенчатой последовательности по формуле i / SAWTOOTH_HIGH ячейке массива с индексом i
    }                                                  // Конец цикла по i
    auto finish = steady_clock::now();                 // Засечь время окончания выполнения функции
    cout << "Последовательность лестницей: "
         << duration_cast<microseconds>(finish - start).count()   // Вывести, сколько времени потребовалось для выполнения функции
         << " mcs" << endl;
    return result;                                     // Возвращение сформированного массива
}
float* FloatQuasiRandomSequenceGeneration(const size_t size){   // Функция, принимает размер создаваемой ступенчатой последовательности и возвращает указатель на сформированную 
    steady_clock::time_point start = steady_clock::now(); // Засечь начальный момент времени
    float* result = new float [size];                          // Создание итогового массива размера size
    for(size_t i = 0; i < size; ++i){                  // Цикл по i для перебора всего массива
        result[i] = (i / STAIRS_LENGTH + rand() % 5) * 1.5;   // Присваивание соответствующего значения ступенчатой последовательности по формуле i / SAWTOOTH_HIGH ячейке массива с индексом i
    }                                                  // Конец цикла по i
    auto finish = steady_clock::now();                 // Засечь время окончания выполнения функции
    cout << "Квазислучайная последовательность: "
         << duration_cast<microseconds>(finish - start).count()   // Вывести, сколько времени потребовалось для выполнения функции
         << " mcs" << endl;
    return result;                                     // Возвращение сформированного массива
}

typedef int* (*MENU_I)(const size_t);   // Переопределение для использования указателя на функцию
typedef float* (*MENU_F)(const size_t); // Переопределение для использования указателя на функцию

int main(){ // Главная исполняемая функция
    srand(time(NULL)); // Обнуление "зерна" времени
    size_t size; // Объявление переменной (беззнаковая, целая), в которой будет храниться размер массива
    cout << "Введите размер массива: "; // Вывод с помощью стандратного потока вывода сообщения о вводе размера массива
    cin >> size; // Ввод с помощью стандартного потока ввода объявленного размера
    cout << endl;
    MENU_I Sequences[] = {IncreasingSequenceGeneration, DescendingSequenceGeneration, // Создание массива указателей на функции
                        RandomGeneration, SinusSequenceGeneration, 
                        SawtoothSequenceGeneration, StairsSequenceGeneration, 
                        QuasiRandomSequenceGeneration};
    MENU_F Float_Sequences[] = {FloatIncreasingSequenceGeneration, FloatDescendingSequenceGeneration, // Создание массива указателей на функции
                        FloatRandomGeneration, FloatSinusSequenceGeneration, 
                        FloatSawtoothSequenceGeneration, FloatStairsSequenceGeneration, 
                        FloatQuasiRandomSequenceGeneration};

    /* ============================================================================================================================
    *                                                  ЦЕЛОЧИСЛЕННЫЕ ПОСЛЕДОВАТЕЛЬНОСТИ
    *  ============================================================================================================================ */
    cout << "=====================      ЦЕЛОЧИСЛЕННЫЕ ПОСЛЕДОВАТЕЛЬНОСТИ       =====================" << endl;
    int *arr_int; // Создание указателя на область в памяти для работы с целочисленным массивом

    {                                               // =========== Блок с работой с возрастающей последовательностью ===============

        arr_int = Sequences[0](size);                   // Инициализация массива возрастающей последовательностью
        FILE* output;                               // Объявление выходного файла
        output = fopen(INT_INCREASING_FILE_NAME, "w");  // Открытие выходного файла в режиме чтения
        if(output){                                 // Если файл удалось открыть/создать
            for(int i = 0; i < size; ++i){          // Перебор всех элементов сформированного массива
                fprintf(output, "%d\n", arr_int[i]);    // Занесение текущего значения ячейки массива в выходной файл
            }                                       // Конец цикла
            fclose(output);                         // Закрытие выходного файла
        } else {                                    // Если файл не удалось открыть
            cerr << "Невозможно открыть файл " << INT_INCREASING_FILE_NAME << endl; // Вывести сообщение об ошибке
        }
    }                                               // =========== Конец блока с работой с возрастающей последовательностью ========

    {                                               // =========== Блок с работой с убывающей последовательностью ==================

        arr_int = Sequences[1](size);                   // Инициализация массива убывающей последовательностью
        FILE* output;                               // Объявление выходного файла
        output = fopen(INT_DESCENDING_FILE_NAME, "w");  // Открытие выходного файла в режиме чтения
        if(output){                                 // Если файл удалось открыть/создать
            for(int i = 0; i < size; ++i){          // Перебор всех элементов сформированного массива
                fprintf(output, "%d\n", arr_int[i]);    // Занесение текущего значения ячейки массива в выходной файл
            }                                       // Конец цикла
            fclose(output);                         // Закрытие выходного файла
        } else {                                    // Если файл не удалось открыть
            cerr << "Невозможно открыть файл " << INT_DESCENDING_FILE_NAME << endl; // Вывести сообщение об ошибке
        }
    }                                               // =========== Конец блока с работой с убывающей последовательностью ==========


    {                                               // =========== Блок с работой со случайной последовательностью ================

        arr_int = Sequences[2](size);                   // Инициализация массива случайной последовательностью
        FILE* output;                               // Объявление выходного файла
        output = fopen(INT_RANDOM_FILE_NAME, "w");      // Открытие выходного файла в режиме чтения
        if(output){                                 // Если файл удалось открыть/создать
            for(int i = 0; i < size; ++i){          // Перебор всех элементов сформированного массива
                fprintf(output, "%d\n", arr_int[i]);    // Занесение текущего значения ячейки массива в выходной файл
            }                                       // Конец цикла
            fclose(output);                         // Закрытие выходного файла
        } else {                                    // Если файл не удалось открыть
            cerr << "Невозможно открыть файл " << INT_RANDOM_FILE_NAME << endl; // Вывести сообщение об ошибке
        }
    }                                               // =========== Конец блока с работой со случайной последовательностью =========


    {                                               // =========== Блок с работой с синусоидальной последовательностью ============

        arr_int = Sequences[3](size);                   // Инициализация массива синусоидальной последовательностью
        FILE* output;                               // Объявление выходного файла
        output = fopen(INT_SINUS_FILE_NAME, "w");       // Открытие выходного файла в режиме чтения
        if(output){                                 // Если файл удалось открыть/создать
            for(int i = 0; i < size; ++i){          // Перебор всех элементов сформированного массива
                fprintf(output, "%d\n", arr_int[i]);    // Занесение текущего значения ячейки массива в выходной файл
            }                                       // Конец цикла
            fclose(output);                         // Закрытие выходного файла
        } else {                                    // Если файл не удалось открыть
            cerr << "Невозможно открыть файл " << INT_SINUS_FILE_NAME << endl; // Вывести сообщение об ошибке
        }
    }                                               // =========== Конец блока с работой с синусоидальной последовательностью =====


    {                                               // =========== Блок с работой с пилообразной последовательностью ==============

        arr_int = Sequences[4](size);                   // Инициализация массива пилообразной последовательностью
        FILE* output;                               // Объявление выходного файла
        output = fopen(INT_SAWTOOTH_FILE_NAME, "w");    // Открытие выходного файла в режиме чтения
        if(output){                                 // Если файл удалось открыть/создать
            for(int i = 0; i < size; ++i){          // Перебор всех элементов сформированного массива
                fprintf(output, "%d\n", arr_int[i]);    // Занесение текущего значения ячейки массива в выходной файл
            }                                       // Конец цикла
            fclose(output);                         // Закрытие выходного файла
        } else {                                    // Если файл не удалось открыть
            cerr << "Невозможно открыть файл " << INT_SAWTOOTH_FILE_NAME << endl; // Вывести сообщение об ошибке
        }
    }                                               // =========== Конец блока с работой с пилообразной последовательностью =======


    {                                               // =========== Блок с работой со ступенчатой последовательностью ==============

        arr_int = Sequences[5](size);                   // Инициализация массива ступенчатой последовательностью
        FILE* output;                               // Объявление выходного файла
        output = fopen(INT_STAIRS_FILE_NAME, "w");      // Открытие выходного файла в режиме чтения
        if(output){                                 // Если файл удалось открыть/создать
            for(int i = 0; i < size; ++i){          // Перебор всех элементов сформированного массива
                fprintf(output, "%d\n", arr_int[i]);    // Занесение текущего значения ячейки массива в выходной файл
            }                                       // Конец цикла
            fclose(output);                         // Закрытие выходного файла
        } else {                                    // Если файл не удалось открыть
            cerr << "Невозможно открыть файл " << INT_STAIRS_FILE_NAME << endl; // Вывести сообщение об ошибке
        }
    }                                               // =========== Конец блока с работой со ступенчатой последовательностью =======

    {                                               // =========== Блок с квазислучайной последовательностью ======================
        arr_int = Sequences[6](size);               // Инициализация массива ступенчатой последовательностью
        FILE* output;                               // Объявление выходного файла
        output = fopen(INT_QUASI_FILE_NAME, "w");       // Открытие выходного файла в режиме чтения
        if(output){                                 // Если файл удалось открыть/создать
            for(int i = 0; i < size; ++i){          // Перебор всех элементов сформированного массива
                fprintf(output, "%d\n", arr_int[i]);    // Занесение текущего значения ячейки массива в выходной файл
            }                                       // Конец цикла
            fclose(output);                         // Закрытие выходного файла
        } else {                                    // Если файл не удалось открыть
            cerr << "Невозможно открыть файл " << INT_QUASI_FILE_NAME << endl; // Вывести сообщение об ошибке
        }
    }                                               // =========== Конец блока с работой с квазислучайной последовательностью =====

    delete[] arr_int;                                   // Высвобождение памяти из-под динамического массива



    /* ============================================================================================================================
    *                                             ПОСЛЕДОВАТЕЛЬНОСТИ С ПЛАВАЮЩЕЙ ТОЧКОЙ
    *  ============================================================================================================================ */
    cout << endl << endl;
    cout << "=====================      ПОСЛЕДОВАТЕЛЬНОСТИ С ПЛАВАЮЩЕЙ ТОЧКОЙ       ================" << endl;
    float *arr_float; // Создание указателя на область в памяти для работы с целочисленным массивом

    {                                               // =========== Блок с работой с возрастающей последовательностью ===============

        arr_float = Float_Sequences[0](size);                   // Инициализация массива возрастающей последовательностью
        FILE* output;                               // Объявление выходного файла
        output = fopen(FLOAT_INCREASING_FILE_NAME, "w");  // Открытие выходного файла в режиме чтения
        if(output){                                 // Если файл удалось открыть/создать
            for(int i = 0; i < size; ++i){          // Перебор всех элементов сформированного массива
                fprintf(output, "%f\n", arr_float[i]);    // Занесение текущего значения ячейки массива в выходной файл
            }                                       // Конец цикла
            fclose(output);                         // Закрытие выходного файла
        } else {                                    // Если файл не удалось открыть
            cerr << "Невозможно открыть файл " << FLOAT_INCREASING_FILE_NAME << endl; // Вывести сообщение об ошибке
        }
    }                                               // =========== Конец блока с работой с возрастающей последовательностью ========


    {                                               // =========== Блок с работой с убывающей последовательностью ==================

        arr_float = Float_Sequences[1](size);                   // Инициализация массива убывающей последовательностью
        FILE* output;                               // Объявление выходного файла
        output = fopen(FLOAT_DESCENDING_FILE_NAME, "w");  // Открытие выходного файла в режиме чтения
        if(output){                                 // Если файл удалось открыть/создать
            for(int i = 0; i < size; ++i){          // Перебор всех элементов сформированного массива
                fprintf(output, "%f\n", arr_float[i]);    // Занесение текущего значения ячейки массива в выходной файл
            }                                       // Конец цикла
            fclose(output);                         // Закрытие выходного файла
        } else {                                    // Если файл не удалось открыть
            cerr << "Невозможно открыть файл " << FLOAT_DESCENDING_FILE_NAME << endl; // Вывести сообщение об ошибке
        }
    }                                               // =========== Конец блока с работой с убывающей последовательностью ==========


    {                                               // =========== Блок с работой со случайной последовательностью ================

        arr_float = Float_Sequences[2](size);                   // Инициализация массива случайной последовательностью
        FILE* output;                               // Объявление выходного файла
        output = fopen(FLOAT_RANDOM_FILE_NAME, "w");      // Открытие выходного файла в режиме чтения
        if(output){                                 // Если файл удалось открыть/создать
            for(int i = 0; i < size; ++i){          // Перебор всех элементов сформированного массива
                fprintf(output, "%f\n", arr_float[i]);    // Занесение текущего значения ячейки массива в выходной файл
            }                                       // Конец цикла
            fclose(output);                         // Закрытие выходного файла
        } else {                                    // Если файл не удалось открыть
            cerr << "Невозможно открыть файл " << FLOAT_RANDOM_FILE_NAME << endl; // Вывести сообщение об ошибке
        }
    }                                               // =========== Конец блока с работой со случайной последовательностью =========


    {                                               // =========== Блок с работой с синусоидальной последовательностью ============

        arr_float = Float_Sequences[3](size);                   // Инициализация массива синусоидальной последовательностью
        FILE* output;                               // Объявление выходного файла
        output = fopen(FLOAT_SINUS_FILE_NAME, "w");       // Открытие выходного файла в режиме чтения
        if(output){                                 // Если файл удалось открыть/создать
            for(int i = 0; i < size; ++i){          // Перебор всех элементов сформированного массива
                fprintf(output, "%f\n", arr_float[i]);    // Занесение текущего значения ячейки массива в выходной файл
            }                                       // Конец цикла
            fclose(output);                         // Закрытие выходного файла
        } else {                                    // Если файл не удалось открыть
            cerr << "Невозможно открыть файл " << FLOAT_SINUS_FILE_NAME << endl; // Вывести сообщение об ошибке
        }
    }                                               // =========== Конец блока с работой с синусоидальной последовательностью =====


    {                                               // =========== Блок с работой с пилообразной последовательностью ==============

        arr_float = Float_Sequences[4](size);                   // Инициализация массива пилообразной последовательностью
        FILE* output;                               // Объявление выходного файла
        output = fopen(FLOAT_SAWTOOTH_FILE_NAME, "w");    // Открытие выходного файла в режиме чтения
        if(output){                                 // Если файл удалось открыть/создать
            for(int i = 0; i < size; ++i){          // Перебор всех элементов сформированного массива
                fprintf(output, "%f\n", arr_float[i]);    // Занесение текущего значения ячейки массива в выходной файл
            }                                       // Конец цикла
            fclose(output);                         // Закрытие выходного файла
        } else {                                    // Если файл не удалось открыть
            cerr << "Невозможно открыть файл " << FLOAT_SAWTOOTH_FILE_NAME << endl; // Вывести сообщение об ошибке
        }
    }                                               // =========== Конец блока с работой с пилообразной последовательностью =======


    {                                               // =========== Блок с работой со ступенчатой последовательностью ==============

        arr_float = Float_Sequences[5](size);                   // Инициализация массива ступенчатой последовательностью
        FILE* output;                               // Объявление выходного файла
        output = fopen(FLOAT_STAIRS_FILE_NAME, "w");      // Открытие выходного файла в режиме чтения
        if(output){                                 // Если файл удалось открыть/создать
            for(int i = 0; i < size; ++i){          // Перебор всех элементов сформированного массива
                fprintf(output, "%f\n", arr_float[i]);    // Занесение текущего значения ячейки массива в выходной файл
            }                                       // Конец цикла
            fclose(output);                         // Закрытие выходного файла
        } else {                                    // Если файл не удалось открыть
            cerr << "Невозможно открыть файл " << FLOAT_STAIRS_FILE_NAME << endl; // Вывести сообщение об ошибке
        }
    }                                               // =========== Конец блока с работой со ступенчатой последовательностью =======

    {                                               // =========== Блок с квазислучайной последовательностью ======================

        arr_float = Float_Sequences[6](size);                   // Инициализация массива ступенчатой последовательностью
        FILE* output;                               // Объявление выходного файла
        output = fopen(FLOAT_QUASI_FILE_NAME, "w");      // Открытие выходного файла в режиме чтения
        if(output){                                 // Если файл удалось открыть/создать
            for(int i = 0; i < size; ++i){          // Перебор всех элементов сформированного массива
                fprintf(output, "%f\n", arr_float[i]);    // Занесение текущего значения ячейки массива в выходной файл
            }                                       // Конец цикла
            fclose(output);                         // Закрытие выходного файла
        } else {                                    // Если файл не удалось открыть
            cerr << "Невозможно открыть файл " << FLOAT_QUASI_FILE_NAME << endl; // Вывести сообщение об ошибке
        }
    }                                               // =========== Конец блока с работой с квазислучайной последовательностью =====

    delete[] arr_float;                                   // Высвобождение памяти из-под динамического массива
    return 0;                                       // Программа возвращает 0 - корректное завершение работы
}
