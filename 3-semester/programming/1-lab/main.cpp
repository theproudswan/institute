#include <iostream>  // Библиотека для работы с входным и выходным потоками
#include <cmath>     // Библиотека для работы с математическими функциями
#include <chrono>    // Библиотека для вычисления времени работы

#define INCREASING_FILE_NAME "inc_output.txt"       // Название выходного файла для возрастающей последовательности
#define DESCENDING_FILE_NAME "dec_output.txt"       // Название выходного файла для убывающей последовательности
#define RANDOM_FILE_NAME "rand_output.txt"          // Название выходного файла для случайной последовательности
#define SINUS_FILE_NAME "sin_output.txt"            // Название выходного файла для синусоидальной последовательности
#define SAWTOOTH_FILE_NAME "sawtooth_output.txt"    // Название выходного файла для пилообразной последовательности
#define STAIRS_FILE_NAME "stairs_output.txt"        // Название выходного файла для ступенчатой последовательности

#define RANDOM_RANGE 100 // Диапазон случайных чисел (от 0 до 99 включительно)
#define SAWTOOTH_HIGH 5  // Высота пилообразной последовательности минус 1
#define STAIRS_LENGTH 5  // Длина ступенчатой последовательности

using namespace std;         // Пространство имён std для использования функций стандартной библиотеки
using namespace std::chrono; // Пространство имён std::chrono для использования функций работы со временем

int* IncreasingSequenceGeneration(const size_t size){  // Функция, принимает размер создаваемой возрастающей последовательности и возвращает указатель на сформированную 
    steady_clock::time_point start = steady_clock::now(); // Засечь начальный момент времени
    int* result = new int [size];                      // Создание итогового массива размера size
    for(size_t i = 0; i < size; ++i){                  // Цикл по i для перебора всего массива
        result[i] = i;                                 // Присваивание соответствующего значения по возрастанию ячейке массива с индексом i
    }                                                  // Конец цикла по i
    auto finish = steady_clock::now();                 // Засечь время окончания выполнения функции
    cout << "Возрастающая последовательность: "
         << duration_cast<microseconds>(finish - start).count()   // Вывести, сколько времени потребовалось для выполнения функции
         << " mcs" << endl;
    return result;                                     // Возвращение сформированного массива
}
int* DescendingSequenceGeneration(const size_t size){  // Функция, принимает размер создаваемой убывающей последовательности и возвращает указатель на сформированную 
    steady_clock::time_point start = steady_clock::now(); // Засечь начальный момент времени
    int* result = new int [size];                      // Создание итогового массива размера size
    for(size_t i = 0; i < size; ++i){                  // Цикл по i для перебора всего массива
        result[i] = size - i - 1;                      // Присваивание соответствующего значения по убыванию ячейке массива с индексом i
    }                                                  // Конец цикла по i  
    auto finish = steady_clock::now();                 // Засечь время окончания выполнения функции
    cout << "Убывающая последовательность: "
         << duration_cast<microseconds>(finish - start).count()   // Вывести, сколько времени потребовалось для выполнения функции
         << " mcs" << endl;
    return result;                                     // Возвращение сформированного массива
}
int* RandomGeneration(const size_t size){              // Функция, принимает размер создаваемой случайной последовательности и возвращает указатель на сформированную 
    steady_clock::time_point start = steady_clock::now(); // Засечь начальный момент времени
    int* result = new int [size];                      // Создание итогового массива размера size
    for(size_t i = 0; i < size; ++i){                  // Цикл по i для перебора всего массива
        result[i] = rand() % RANDOM_RANGE;             // Присваивание соответствующего случайного значения ячейке массива с индексом i
    }                                                  // Конец цикла по i
    auto finish = steady_clock::now();                 // Засечь время окончания выполнения функции
    cout << "Случайное заполнение: "
         << duration_cast<microseconds>(finish - start).count()   // Вывести, сколько времени потребовалось для выполнения функции
         << " mcs" << endl;
    return result;                                     // Возвращение сформированного массива
}
int* SinusSequenceGeneration(const size_t size){       // Функция, принимает размер создаваемой синусоидальной последовательности и возвращает указатель на сформированную 
    steady_clock::time_point start = steady_clock::now(); // Засечь начальный момент времени
    int* result = new int [size];                      // Создание итогового массива размера size
    for(size_t i = 0; i < size; ++i){                  // Цикл по i для перебора всего массива
        result[i] = sin(i) * 10;                       // Присваивание соответствующего значения синуса i ячейке массива с индексом i
    }                                                  // Конец цикла по i
    auto finish = steady_clock::now();                 // Засечь время окончания выполнения функции
    cout << "Синусоидальная последовательность: "
         << duration_cast<microseconds>(finish - start).count()   // Вывести, сколько времени потребовалось для выполнения функции
         << " mcs" << endl;
    return result;                                     // Возвращение сформированного массива
}
int* SawtoothSequenceGeneration(const size_t size){    // Функция, принимает размер создаваемой пилообразной последовательности и возвращает указатель на сформированную 
    steady_clock::time_point start = steady_clock::now(); // Засечь начальный момент времени
    int* result = new int [size];                      // Создание итогового массива размера size
    for(size_t i = 0; i < size; ++i){                  // Цикл по i для перебора всего массива
        result[i] = i % SAWTOOTH_HIGH;                 // Присваивание соответствующего значения пилообразной последовательности по формуле i % SAWTOOTH_HIGH ячейке массива с индексом i
    }                                                  // Конец цикла по i
    auto finish = steady_clock::now();                 // Засечь время окончания выполнения функции
    cout << "Пилообразная последовательность: "
         << duration_cast<microseconds>(finish - start).count()   // Вывести, сколько времени потребовалось для выполнения функции
         << " mcs" << endl;
    return result;                                     // Возвращение сформированного массива
}
int* StairsSequenceGeneration(const size_t size){      // Функция, принимает размер создаваемой ступенчатой последовательности и возвращает указатель на сформированную 
    steady_clock::time_point start = steady_clock::now(); // Засечь начальный момент времени
    int* result = new int [size];                      // Создание итогового массива размера size
    for(size_t i = 0; i < size; ++i){                  // Цикл по i для перебора всего массива
        result[i] = i / STAIRS_LENGTH;                 // Присваивание соответствующего значения ступенчатой последовательности по формуле i / SAWTOOTH_HIGH ячейке массива с индексом i
    }                                                  // Конец цикла по i
    auto finish = steady_clock::now();                 // Засечь время окончания выполнения функции
    cout << "Последовательность лестницей: "
         << duration_cast<microseconds>(finish - start).count()   // Вывести, сколько времени потребовалось для выполнения функции
         << " mcs" << endl;
    return result;                                     // Возвращение сформированного массива
}

typedef int* (*MENU)(const size_t); // Переопределение для использования указателя на функцию

int main(){ // Главная исполняемая функция
    srand(time(NULL)); // Обнуление "зерна" времени
    size_t size; // Объявление переменной (беззнаковая, целая), в которой будет храниться размер массива
    cout << "Введите размер массива: "; // Вывод с помощью стандратного потока вывода сообщения о вводе размера массива
    cin >> size; // Ввод с помощью стандартного потока ввода объявленного размера
    cout << endl;
    MENU Sequences[] = {IncreasingSequenceGeneration, DescendingSequenceGeneration, // Создание массива указателей на функции
                        RandomGeneration, SinusSequenceGeneration, 
                        SawtoothSequenceGeneration, StairsSequenceGeneration};
    int *arr; // Создание указателя на область в памяти

    {                                               // =========== Блок с работой с возрастающей последовательностью ===============

        arr = Sequences[0](size);                   // Инициализация массива возрастающей последовательностью
        FILE* output;                               // Объявление выходного файла
        output = fopen(INCREASING_FILE_NAME, "w");  // Открытие выходного файла в режиме чтения
        if(output){                                 // Если файл удалось открыть/создать
            for(int i = 0; i < size; ++i){          // Перебор всех элементов сформированного массива
                fprintf(output, "%d\n", arr[i]);    // Занесение текущего значения ячейки массива в выходной файл
            }                                       // Конец цикла
            fclose(output);                         // Закрытие выходного файла
        } else {                                    // Если файл не удалось открыть
            cerr << "Невозможно открыть файл " << INCREASING_FILE_NAME << endl; // Вывести сообщение об ошибке
        }
    }                                               // =========== Конец блока с работой с возрастающей последовательностью ========


    {                                               // =========== Блок с работой с убывающей последовательностью ==================

        arr = Sequences[1](size);                   // Инициализация массива убывающей последовательностью
        FILE* output;                               // Объявление выходного файла
        output = fopen(DESCENDING_FILE_NAME, "w");  // Открытие выходного файла в режиме чтения
        if(output){                                 // Если файл удалось открыть/создать
            for(int i = 0; i < size; ++i){          // Перебор всех элементов сформированного массива
                fprintf(output, "%d\n", arr[i]);    // Занесение текущего значения ячейки массива в выходной файл
            }                                       // Конец цикла
            fclose(output);                         // Закрытие выходного файла
        } else {                                    // Если файл не удалось открыть
            cerr << "Невозможно открыть файл " << DESCENDING_FILE_NAME << endl; // Вывести сообщение об ошибке
        }
    }                                               // =========== Конец блока с работой с убывающей последовательностью ==========


    {                                               // =========== Блок с работой со случайной последовательностью ================

        arr = Sequences[2](size);                   // Инициализация массива случайной последовательностью
        FILE* output;                               // Объявление выходного файла
        output = fopen(RANDOM_FILE_NAME, "w");      // Открытие выходного файла в режиме чтения
        if(output){                                 // Если файл удалось открыть/создать
            for(int i = 0; i < size; ++i){          // Перебор всех элементов сформированного массива
                fprintf(output, "%d\n", arr[i]);    // Занесение текущего значения ячейки массива в выходной файл
            }                                       // Конец цикла
            fclose(output);                         // Закрытие выходного файла
        } else {                                    // Если файл не удалось открыть
            cerr << "Невозможно открыть файл " << RANDOM_FILE_NAME << endl; // Вывести сообщение об ошибке
        }
    }                                               // =========== Конец блока с работой со случайной последовательностью =========


    {                                               // =========== Блок с работой с синусоидальной последовательностью ============

        arr = Sequences[3](size);                   // Инициализация массива синусоидальной последовательностью
        FILE* output;                               // Объявление выходного файла
        output = fopen(SINUS_FILE_NAME, "w");       // Открытие выходного файла в режиме чтения
        if(output){                                 // Если файл удалось открыть/создать
            for(int i = 0; i < size; ++i){          // Перебор всех элементов сформированного массива
                fprintf(output, "%d\n", arr[i]);    // Занесение текущего значения ячейки массива в выходной файл
            }                                       // Конец цикла
            fclose(output);                         // Закрытие выходного файла
        } else {                                    // Если файл не удалось открыть
            cerr << "Невозможно открыть файл " << SINUS_FILE_NAME << endl; // Вывести сообщение об ошибке
        }
    }                                               // =========== Конец блока с работой с синусоидальной последовательностью =====


    {                                               // =========== Блок с работой с пилообразной последовательностью ==============

        arr = Sequences[4](size);                   // Инициализация массива пилообразной последовательностью
        FILE* output;                               // Объявление выходного файла
        output = fopen(SAWTOOTH_FILE_NAME, "w");    // Открытие выходного файла в режиме чтения
        if(output){                                 // Если файл удалось открыть/создать
            for(int i = 0; i < size; ++i){          // Перебор всех элементов сформированного массива
                fprintf(output, "%d\n", arr[i]);    // Занесение текущего значения ячейки массива в выходной файл
            }                                       // Конец цикла
            fclose(output);                         // Закрытие выходного файла
        } else {                                    // Если файл не удалось открыть
            cerr << "Невозможно открыть файл " << SAWTOOTH_FILE_NAME << endl; // Вывести сообщение об ошибке
        }
    }                                               // =========== Конец блока с работой с пилообразной последовательностью =======


    {                                               // =========== Блок с работой со ступенчатой последовательностью ==============

        arr = Sequences[5](size);                   // Инициализация массива ступенчатой последовательностью
        FILE* output;                               // Объявление выходного файла
        output = fopen(STAIRS_FILE_NAME, "w");      // Открытие выходного файла в режиме чтения
        if(output){                                 // Если файл удалось открыть/создать
            for(int i = 0; i < size; ++i){          // Перебор всех элементов сформированного массива
                fprintf(output, "%d\n", arr[i]);    // Занесение текущего значения ячейки массива в выходной файл
            }                                       // Конец цикла
            fclose(output);                         // Закрытие выходного файла
        } else {                                    // Если файл не удалось открыть
            cerr << "Невозможно открыть файл " << STAIRS_FILE_NAME << endl; // Вывести сообщение об ошибке
        }
    }                                               // =========== Конец блока с работой со ступенчатой последовательностью =======

    delete[] arr;                                   // Высвобождение памяти из-под динамического массива
    return 0;                                       // Программа возвращает 0 - корректное завершение работы
}
