#pragma once    // Для избежания проблемы двойного включения

#include "LinkedList.h" // Заголовочный файл с реализацией списка

//============================================================================
//
//                О Б Ъ Я В Л Е Н И Е  К Л А С С А
//
//============================================================================

template <typename T> 	// Шаблон класса
class Deque{			// Класс Дек
public:					// Публичная секция
	Deque () = default;	// Стандратный конструктор по умолчанию
	Deque (const Deque<T>& lhs) = delete;   // Запрещаем конструктор копирования,
                                            // Т.к. в основе лежит список на сырых указателях
                                            // И может произойти инвалидация
	void Clear();                       // Метод для очистки дека
	const T GetFirst() const;           // Константный метод для получения первого элемента
	T& GetFirst();                      // Метод для получения первого элемента
	const T GetLast() const;            // Константный метод для получения последнего элемента
	T& GetLast();                       // Метод для получения последнего элеммента
	void PushBack(const T& _value);     // Метод для добавления элемента в конец дека
	void PushFront(const T& _value);    // Метод для добавления элемента в начало дека
	void PopFront();                    // Метод для удаления из начала дека
	void PopBack();                     // Метод для удаления из конца дека
	const T operator[] (const size_t index) const; // Константное получение элемента через []
	T& operator[] (const size_t index); // Получение элемента через []
	void Print();                       // Метод для печати дека

private:    // Приватная секция
	LinkedList<T> data; // Двусвязный список
}; // Конец объявления класса Deque




//============================================================================
//
//                О П Р Е Д Е Л Е Н И Е  К Л А С С А
//
//============================================================================




template <typename T>   // Шаблон метода
void Deque<T>::Clear() {
    if (!data.GetSize()) cerr << "Ошибка! Дек уже пуст." << endl; // Предупреждаем, что из пустого дека нечего удалять
    while (data.GetHead()) {    // Пока список не пуст
        data.PopFront();        // Удалить первый элемент
    }                           // Конец "Пока"
} // Конец метода Clear


template <typename T>   // Шаблон метода
const T Deque<T>::GetFirst() const { // Константный метод получения начального элемента дека
    return data.GetHead() -> value;  // Вернуть начальный элемент
} // Конец константного метода GetFirst


template <typename T>   // Шаблон метода
T & Deque<T>::GetFirst() { // Метод получения начального элемента дека
    return data.GetHead() -> value;  // Вернуть начальный элемент
} // Конец метода GetFirst


template <typename T>   // Шаблон метода
const T Deque<T>::GetLast() const { // Константный метод получения последнего элемента дека
    return data.GetTail() -> value; // Вернуть последний элемент
} // Конец константного метода GetLast


template <typename T>   // Шаблон метода
T & Deque<T>::GetLast() { // Метод получения последнего элемента дека
    return data.GetTail() -> value;  // Вернуть последний элемент
} // Конец метода GetLast


template <typename T>   // Шаблон метода
void Deque<T>::PushBack(const T & _value) { // Метод добавления элемента в конец дека
    data.PushBack(_value);  // Добавить элемент в конец списка
}   // Конец метода PushBack


template <typename T>   // Шаблон метода
void Deque<T>::PushFront(const T & _value) { // Метод добавления элемента в начало дека
    data.PushFront(_value); // Добавить элемент в начало списка
} // Конец метода PushFront


template <typename T>   // Шаблон метода
void Deque<T>::PopFront() { // Метод удаления из начала дека
    data.PopFront(); // Удалить элемент из начала списка
} // Конец метода PopFront


template <typename T>   // Шаблон метода
void Deque<T>::PopBack() {  // Метод удаления из конца дека
    data.PopBack(); // Удалить элемент из конца списка
} // Конец метода PopBack


template <typename T>   // Шаблон метода
const T Deque<T>::operator[](const size_t index) const { // Константная перегрузка скобок []
    if (index >= data.GetSize()) {  // Если поступивший индекс больше размера дека
        cerr << "Ошибка! Индекс за пределами дека." << endl; // Вывести Сообщение об ошибке
        return numeric_limits < T > ::min(); // Вернуть невалидное значение
    } // Конец Если
    return data[index] -> value; // Вернуть элемент списка с нужным индексом
} // Конец константной перегрузки скобок []


template <typename T>   // Шаблон метода
T & Deque<T>::operator[](const size_t index) { // Перегрузка скобок []
    if (index >= data.GetSize()) {  // Если поступивший индекс больше размера дека
        cerr << "Ошибка! Индекс за пределами дека." << endl; // Вывести Сообщение об ошибке
        return data[index] -> value; // Вернуть значение кольцевого списка
    }   // Конец Если
    return data[index] -> value; // Вернуть элемент списка с нужным индексом
} // Конец перегрузки скобок []


template <typename T>    // Шаблон метода
void Deque<T>::Print() { // Метод для печати дека
    if (!data.GetSize()) cerr << "Ошибка! Дек пуст." << endl; // Если дек пуст, вывести соответствующее сообщение
    for (size_t i = 0; i < data.GetSize(); ++i) {   // Цикл для перебора всего дека
        cout << "deque[" << i << "] = " << data[i] << endl; // Вывести соответствующий элемент
    } // Конец цикла
} // Конец метода Print
