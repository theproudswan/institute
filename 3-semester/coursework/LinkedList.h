//============================================================================
// Компилятор  : g++ v. 10.2.1
// Название    : LinkedList.h
// Автор       : Лебедев Иван
// Группа      : М3О-211Б-20
// Содержание  : Прототип и определение класса LinkedList
//============================================================================

#pragma once  // Для избежания проблемы двойного включения

#include <iostream>  // Библиотека для работы с потоками ввода/вывода
#include <string>    // Библиотека для работы со строками
#include <limits>    // Библиотека для работы со значениями типов
#include <utility>   // Библиотека для работы с парами

using namespace std; // Пространство имён для работы с функциями стандартной библиотеки

//============================================================================
//
//                О Б Ъ Я В Л Е Н И Е  К Л А С С А
//
//============================================================================

template <typename T>   // Шаблон класса
class LinkedList {      // Начало объявления класса
public:                 // Публичная секция класса

  struct Node {         // Структура для элемента списка
      T value{};        // Поле для хранения значения элемента
      Node* next = nullptr; // Указатель на следующий элемент
  };                    // Конец структуры Node


  LinkedList() = default; // Конструктор по умолчанию
  // LinkedList (const LinkedList<T>& lhs) = delete; // Запрещаем конструктор копирования
  ~LinkedList();          // Деструктор класса LinkedList

  void PushFront(const T& value); // Добавление элемента со значением value в начало списка
  void PushBack(const T& value);  // Добавление элемента со значением value в конец списка
  void PopFront();  // Удаление головы списка
  void PopBack();   // Удаление хвоста списка


  void InsertAfter(Node* node, const T& value); // Вставка элемента со значением value после элемента node
  void RemoveAfter(Node* node); // Удаление после элемента node

  Node* GetHead();              // Получение головы списка
  const Node* GetHead() const;  // Получение головы списка
  Node* GetTail();              // Получение хвоста списка
  const Node* GetTail() const;  // Получение хвоста списка

  bool IsEmpty() const;         // Проверка списка на пустоту
  size_t GetSize() const;       // Получение размера списка

  pair<size_t, T> FindMax() const; // Поиск максимального элемента
  size_t LowerBound(const T& to_find) const; // Поиск первого вхождения элемента со значением to_find
  size_t UpperBound(const T& to_find) const; // Поиск последнего вхождения элемента со значением to_find

  Node* operator[] (const size_t index) const; // Доступ к узлу списка через скобки []
  Node* operator[] (const size_t index); 	   // Доступ к узлу списка через скобки []
private: // Приватная секция
  Node* head = nullptr; // Голова списка
  Node* tail = nullptr; // Хвост списка
  size_t size = 0;      // Счётчик количества элементов
}; // Конец класса LinkedList




//============================================================================
//
//                О П Р Е Д Е Л Е Н И Е  К Л А С С А
//
//============================================================================



template <typename T> // Шаблон деструктора
  LinkedList<T>::~LinkedList(){ // Определение деструктора
    while(head ){ // Пока список не пустой
      PopBack();// Удалить первый элемент
    }            // Конец пока
    cout << "Объект удалён" << endl;
  }              // Конец деструктора


template <typename T> // Шаблон метода
  void LinkedList<T>::PushFront(const T& value){ // Метод добавляет в конец элемент со значем value
    Node* n_ptr = new Node{value}; // Заводим вспомогательный узел
    n_ptr->next = head;            // Следующий узел после вспомогательного - голова
    n_ptr->value = value;          // Вспомогательный список имеет значение value
    if (LinkedList::IsEmpty())     // Если список был пуст
    	head = tail = n_ptr;         // Вспомогательный узел теперь и голова, и хвост
    else                           // В противном случае
    	head = n_ptr;                // Вспомогательный узел теперь голова
    tail->next = head;             // Узел после хвоста - новая голова
    size++;                        // Увеличить счётчик элементов
  } // Конец метода PushFront


template <typename T> // Шаблон метода
  void LinkedList<T>::PushBack(const T& value){ // Метод класса добавляет узел со значением value в конец списка
	  Node* n_ptr = new Node{value};  // Создать вспомогательный узел
	  if (LinkedList::IsEmpty()){     // Если список пуст
		  head = n_ptr;                 // Голова списка - вспомогательный узел
		  tail = n_ptr;                 // Хвост списка - вспомогательный узел
		  size++;                       // Увеличить счётчик элементов
		  return;                       // Закончить
	  }                               // Конец Если
	  n_ptr->next = nullptr;          // Вспомогательный узел не указывает на следующий
	  n_ptr->value = value;           // Вспомогательный узел имеет значение value

	  tail->next = n_ptr;             // Следующий элемент после хвоста - вспомогательный элемент
	  tail = n_ptr;                   // Теперь хвост списка - вспомогательный элемент
	  tail->next = head;              // Следующий после хвоста списка узел - голова
	  size++;                         // Увеличить счётчик элементов
  } // Конец метода PushBack()


template <typename T> // Шаблон метода класса
  void LinkedList<T>::InsertAfter(Node* node, const T& value){ // Метод класса вставляет узел со значением value перед узлом node
      if(node == nullptr){            // Если node пуст
        PushFront(value);             // Добавить value в начало списка
      } else if(node == tail){        // Если node является концом
    	  PushBack(value);              // Добавить value в конец списка
      } else {                        // В противном случае
        Node* tmp = new Node{value};  // Завести вспомогательный узел, куда записать значение value
        tmp->next = node->next;       // Теперь следующий после вспомогательного узла - узел после node
        node->next = tmp;             // Следующий узел после node - вспомогательный
        size++;                       // Увеличить счётчик количества элементов
      }                               // Конец Иначе
  } // Конец метода InsertAfter


template <typename T> // Шаблон метода класса
  void LinkedList<T>::RemoveAfter(Node* node){  // Метод класса удаляет узел после узла node
      if (IsEmpty()){                   // Если список пуст
          cerr << "Нечего удалять! Список пуст." << endl; // Вывести информационное сообщение
          return;     // Вернуть пару из невалидных значений
      }                                 // Конец Если
    if (node == tail){   // Если node пуст
      PopFront();        // Удалить начальный элемент списка
    } else {             // В противном случае
      if((node->next) != nullptr){  // Если элемент после node не пуст
        Node* tmp = node->next;     // Создать вспомогательный узел, куда записать узел после node
        node->next = tmp->next;     // Теперь узел после node равен узлу после вспомогательного
        delete tmp;                 // Удалить вспомогательный узел
        size--;                     // Уменьшить счётчик элементов
      }                             // Конец Если элемент после node не пуст
    }                               // Конец Иначе
  } // Конец метода RemoveAfter


template <typename T> // Шаблон метода класса
  void LinkedList<T>::PopFront(){ // Удаление головы списка
      if (IsEmpty()){                   // Если список пуст
          cerr << "Нечего удалять! Список пуст." << endl; // Вывести информационное сообщение
          return;     // Вернуть пару из невалидных значений
      }
    if(head){                     // Если есть первый элемент
        if (head == tail){        // Если голова является хвостом (в списке всего 1 элемент)
          delete head;            // Удалить голову списка
          head = nullptr;         // Обнулить указатель головы
          size--;                 // Уменьшить счётчик элементов списка
          return;                 // Завершить выполнение
        }                         // Конец Если всего 1 элемент
      Node* n_ptr = head->next;   // Завести вспомогательный узел, куда записать следующий после головы узел
      delete head;                // Высвободить память из-под головы
      head = n_ptr;               // Теперь голова - вспомогательный элемент
      tail->next = head;          // После старого хвоста идёт новая голова
      size--;                     // Уменьшить счётчик элементов
    }                             // Конец Если
  } // Конец метода PopFront


template <typename T> // Шаблон метода класса
  void LinkedList<T>::PopBack(){ // Удаление хвоста списка
      if (IsEmpty()){                   // Если список пуст
          cerr << "Нечего удалять! Список пуст." << endl; // Вывести информационное сообщение
          return;     // Вернуть пару из невалидных значений
      }
	  if(tail){                    // Если есть последний элемент
        if (head == tail){       // Если голова является хвостом (в списке всего 1 элемент)
            delete head;         // Удалить голову списка
            head = nullptr;      // Обнулить указатель головы
            size--;              // Уменьшить счётчик элементов списка
            return;              // Завершить выполнение
        }                        // Конец Если всего 1 элемент
	      Node* n_ptr = head;      // Завести вспомогательный узел, куда записать начало списка
	      size--;                  // Уменьшить счётчик элементов
        for (size_t i = 0; i < size - 1; ++i){
          n_ptr = n_ptr->next;
        }
	      delete tail;             // Высвободить память из-под хвоста
	      tail = n_ptr;            // Теперь вспомогательный узел является хвостом
	      tail->next = head;       // После нового хвоста все еще идет голова
	  }                            // Конец Если
  } // Конец метода PopBack


template <typename T> // Шаблон метода класса
 typename  LinkedList<T>::Node* LinkedList<T>::GetHead() { // Метод для получения головы списка
   return head; // Вернуть голову списка
  } // Конец метода GetHead


template <typename T>
  const typename LinkedList<T>::Node* LinkedList<T>::GetHead() const {  // Константный метод для получения головы списка
    return head;  // Вернуть голову списка
  } // Конец метода GetHead


template <typename T> // Шаблон метода класса
  typename LinkedList<T>::Node* LinkedList<T>::GetTail() { // Метод для получения конца списка
    return tail;  // Вернуть конец списка
  } // Конец метода GetTail()


template <typename T> // Шаблон метода класса
  const typename LinkedList<T>::Node* LinkedList<T>::GetTail() const {  // Константный метод для получения конца списка
    return tail; // Вернуть конец списка
  } // Конец метода GetTail()


template <typename T> // Шаблон метода класса
  bool LinkedList<T>::IsEmpty() const { // Константный метод для определения, пустой ли список
    return size == 0; // Вернуть результат сравнения размера с нулём
  } // Конец метода IsEmpty


template <typename T> // Шаблон метода класса
  size_t LinkedList<T>::GetSize() const { // Константный метод для получения размера списка
     return size; // Вернуть размер списка
  } // Конец метода GetSize


template <typename T> // Шаблон метода класса
  pair<size_t, T> LinkedList<T>::FindMax() const { // Константный метод для поиска наибольшего элемента списка
    size_t index;                       // Позиция наибольшего элемента
	  size_t iter_count = -1;             // Счётчик итераций (всегда на 1 меньше нужного)
	  T max = numeric_limits<T>::min();   // Максимум, изначально имеет минимальное значение типа T
      if (IsEmpty()){                   // Если список пуст
          cerr << "Нечего искать! Список пуст." << endl; // Вывести информационное сообщение
          return make_pair(1, max);     // Вернуть пару из невалидных значений
      }                                 // Конец Если

	  Node* tmp = head;                   // Вспомогательный узел установить на голову списка
	  while(tmp != tail){                 // Пока не дошли до конца списка
		  iter_count++;                     // Увеличить счётчик итераций
		  if (tmp->value > max){            // Если значение текущего узла больше максимума
			  max = tmp->value;               // Записать новый максимум
			  index = iter_count;             // Записать индекс этого максимума
		  }                                 // Конец Если
		  tmp = tmp->next;                  // Перейти к следующему узлу
	  }                                   // Конец Пока
    iter_count++;                       // Увеличить счётчик итераций
    if (tmp->value > max){              // Если значение текущего узла больше максимума
		  max = tmp->value;                 // Записать новый максимум
		  index = iter_count;               // Записать индекс этого максимума
		}                                   // Конец Если
	  return make_pair(index, max);       // Вернуть пару из индекса и максимального значения
  } // Конец метода FindMax()


template <typename T> // Шаблон метода класса
  size_t LinkedList<T>::LowerBound(const T& to_find) const{  // Константный метод поиска первого вхождения элемента to_find
      if (IsEmpty()){                   // Если список пуст
          cerr << "Нечего искать! Список пуст." << endl; // Вывести информационное сообщение
          return 1;     // Вернуть пару из невалидных значений
      }
	  Node* tmp = head;             // Вспомогательный узел установить на начало списка
	  size_t index = 0;             // Индекс установить на начальный элемент
	  while(tmp != tail && tmp){        // Пока вспомогательный узел не равен концу списка и список не пустой
	  		  if(tmp->value == to_find){  // Если значение вспомогательного узла равно искомому
	  			  return index;         // Вернуть индкес этого элемента
	  		  }                       // Конец Если
	  		  tmp = tmp->next;        // Перейти к следующему элементу
	  		  index++;                // Увеличить индекс
	  }                             // Конец Пока
    if(tmp->value == to_find){    // Если конец списка равна искомому элементу
	  	return index;               // Вернуть индекс конца списка
	  }                             // Конец Если
	  return GetSize();             // Вернуть размер списка
  } // Конец метода LowerBound


template <typename T> // Шаблон метода класса
  size_t LinkedList<T>::UpperBound(const T& to_find) const {  // Константный метод поиска последнего вхождения элемента to_find
      if (IsEmpty()){                   // Если список пуст
          cerr << "Нечего искать! Список пуст." << endl; // Вывести информационное сообщение
          return 1;     // Вернуть пару из невалидных значений
      }
  	Node* tmp = head;             // Вспомогательный узел установить на начало списка
	  size_t index = 0;             // Индекс установить на начальный элемент
    size_t position = GetSize();  // Позиция найденного элемента
	  while(tmp != tail && tmp){        // Пока вспомогательный узел не равен концу списка и список не пустой
	  		  if(tmp->value == to_find){  // Если значение вспомогательного узла равно искомому
	  			  position = index;         // Запомнить позицию найденного элемента
	  		  }                       // Конец Если
	  		  tmp = tmp->next;        // Перейти к следующему элементу
	  		  index++;                // Увеличить индекс
	  }                             // Конец Пока
    if(tmp->value == to_find){    // Если конец списка равна искомому элементу
	  	return index;               // Вернуть индекс конца списка
	  }                             // Конец Если
	  return position;              // Вернуть позицию последнего вхождения
   } // Конец метода UpperBound


template <typename T> // Шаблон перегрузки оператора
  typename LinkedList<T>::Node* LinkedList<T>::operator[] (const size_t index) const { // Перегрузка оператора [] для константного доступа к элементу списка по егу индексу
	  Node* tmp = head;    // Вспомогательный узел
	  size_t i = 0;        // Индекс текущего элемента
      while (i < index){ // Пока не дошли до нужного индекса
        tmp = tmp->next; // Перейти к следующему узлу списка
        i++;             // Увеличить количество перебранных элементов
      }                  // Конец Пока
	  return tmp;       // Вернуть узел, на котором остановился цикл
  }                   // Конец перегрузки оператора []

template <typename T> // Шаблон перегрузки оператора
  typename LinkedList<T>::Node* LinkedList<T>::operator[] (const size_t index) { // Перегрузка оператора [] для константного доступа к элементу списка по егу индексу
	  Node* tmp = head;    // Вспомогательный узел
	  size_t i = 0;        // Индекс текущего элемента
      while (i < index){ // Пока не дошли до нужного индекса
        tmp = tmp->next; // Перейти к следующему узлу списка
        i++;             // Увеличить количество перебранных элементов
      }                  // Конец Пока
	  return tmp;       // Вернуть узел, на котором остановился цикл
  }                   // Конец перегрузки оператора []

//============================================================================
//
//             К О Н Е Ц  О П Р Е Д Е Л Е Н И Я  К Л А С С А
//
//============================================================================